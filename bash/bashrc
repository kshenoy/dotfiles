# NOTE: exporting a variable makes it available for child processes via the environment

# Proceed only if its an interactive shell
[[ $- == *i* ]] || return

# local init. Any local settings that need to be set initially go here
[[ -f ~/.bashrc_local_init ]] && . ~/.bashrc_local_init

# interactive, login shell settings
# Turn off TTY "start" and "stop" commands in all interactive shells.
# They default to ~C-q~ and ~C-s~. I want to use ~C-s~ to do forward history search.
stty start ''
stty stop  ''
stty -ixon # disable XON/XOFF flow control
stty ixoff # enable sending (to app) of start/stop characters
stty ixany # let any character restart output, not only start character

# default permissions
umask 002

# [[https://unix.stackexchange.com/questions/32409/set-and-shopt-why-two][shopt v/s set]]
# Using [[https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html][shopt]]:
# ~-s~ : set
# ~-u~ : unset
# ~-q~ : query whether set/unset
# [[http://wiki.bash-hackers.org/internals/shell_options][List of shell options]]

# Directory and completion options
shopt -s cdable_vars  # Allow cd to variable names containing directory paths
shopt -s cdspell      # Auto-correct minor typos in directory names
shopt -s checkhash    # Check if hashed commands still exist before executing
shopt -s checkjobs    # List stopped/running jobs before exiting shell
shopt -s checkwinsize # Update LINES and COLUMNS after each command
shopt -s direxpand    # Expand directory names (prevents escaping $ in $dir_variable)
shopt -s dirspell     # Auto-correct directory names during completion
shopt -s dotglob      # Include hidden files in filename expansion

# Optional shopt options (currently disabled)
# shopt -s expand_aliases        # Expand aliases
# shopt -s extglob               # Extended pattern matching
# shopt -s failglob              # Error on failed glob expansion
# shopt -s globstar              # ** matches files and directories (too slow, using @ function instead)
# shopt -s gnu_errfmt            # GNU error message format
# shopt -s no_empty_cmd_completion  # Don't search PATH for completions on empty line
# shopt -s nocaseglob            # Case-insensitive filename expansion
# shopt -s nocasematch           # Case-insensitive pattern matching
# shopt -s nullglob              # Non-matching patterns expand to null

shopt -s huponexit     # Send SIGHUP to jobs when interactive login shell exits
shopt -s lastpipe      # Run last command of pipeline in current shell
shopt -s lithist       # Save multi-line commands with embedded newlines
shopt -s mailwarn      # Warn if mail file has been accessed
shopt -s shift_verbose # Print error when shift count exceeds parameters

set -o noclobber
#set -o vi
set bell-style none
# Otherwise some completions will fail
set +o nounset

# History
shopt -s histappend    # Append to history file instead of overwriting
shopt -s histreedit    # Allow re-editing failed history substitutions
shopt -s histverify    # Load history substitutions into readline buffer for confirmation

# Increase size of history in the terminal. Default is a measly 512 lines
export HISTSIZE=65535
export HISTFILESIZE=65535

# Add timestamps to history
export HISTTIMEFORMAT="%F %T  "

# Ignore duplicates and trivial one/two char commands as I've a bad habit of doing =cl= all the time.
export HISTIGNORE='?:??:history*:sosc:que*:ll*'

# `ignoredups` allows me to ignore the same command type multiple times consecutively
# `ignorespace` does not add commands that start with a space to the history just in case I don't want to log something
# `ignoreboth` does both
export HISTCONTROL=ignoreboth

# Misc
export EDITOR=nvim
export VISUAL=gvim

# Make less more friendly for non-text input files, see lesspipe(1)
export MANPAGER=less
export PAGER=less
[[ -x /usr/bin/lesspipe ]] && eval "$(SHELL=/bin/sh lesspipe)"

export HOSTNAME="$(hostname)"
export LANG=en_US.UTF-8

# ls colors
if [[ -x /usr/bin/dircolors ]]; then
    _dircolors=${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/bash/dircolors.rc
    [[ -r $_dircolors ]] && eval "$(/usr/bin/dircolors -b $_dircolors)" || eval "$(/usr/bin/dircolors -b)"
fi

# colored man pages with less
man() {
    env \
        LESS_TERMCAP_mb=$(printf "\e[1;31m") \
        LESS_TERMCAP_md=$(printf "\e[1;31m") \
        LESS_TERMCAP_me=$(printf "\e[0m") \
        LESS_TERMCAP_se=$(printf "\e[0m") \
        LESS_TERMCAP_so=$(printf "\e[0;43;30m") \
        LESS_TERMCAP_ue=$(printf "\e[0m") \
        LESS_TERMCAP_us=$(printf "\e[1;32m") \
        man "$@"
}

# alert
# Simply function to "alert" when a command completes.
# NOTE: This must be used as a function to have access to the history via the fc command

# Use like this: `sleep 10 && alert`

unset -f alert
alert() {
    # Pick up display message if provided as argument. If not show the last command that was run
    local _msg=${1:-"'$(fc -nl -1 | sed -e 's/^\s*//' -e 's/\s*[;&|]\+\s*alert$//')' has completed"}

    # Add TMUX information if available
    if [[ -n $TMUX ]]; then
        _msg="$(tmux display-message -p "[#S:#I.#P]") $_msg"
    else
        _msg="[$$] $_msg"
    fi

    # Indicate normal completion or error
    local _icon=$( (($? == 0)) && echo terminal || echo error)

    notify-send --urgency=low -i $_icon "$_msg"
}

#=======================================================================================================================
# calc: Simple wrapper around `irb` to make it more natural to use. eg. `= 4 + 5`
unset -f =
=() {
    local _input="${@:-$(</dev/stdin)}"
    # echo $_input

    # if [[ $_input =~ [:xdigit:]+\[[:digit:]+:[:digit:]+\] ]]; then
    #   _input=${_input#.*[}
    #   echo $_input
    #   return
    # fi
    # = "($_input >> $_lsb) & ($_msb - $_lsb)"

    # If there's no explicit output formatting, try to infer from the input
    if [[ ! $_input =~ to_s ]]; then
        if [[ $_input =~ 0x ]] || [[ $_input =~ [a-fA-F] ]]; then
            local _base=16
        elif [[ $_input =~ 0b ]]; then
            local _base=2
        fi
        _input="($_input).to_s($_base)"
    fi

    local _result=$(echo "$_input" | irb --noverbose | command sed 's/"//g')

    # Pretty-print formatted output
    if [[ $_input =~ 'to_s(16)' ]]; then
        _result="0x${_result}"
    elif [[ $_input =~ 'to_s(2)' ]]; then
        _result="0b${_result}"
    fi

    echo $_result
}

# Simple base-converter
unset -f =base
=base() (
    _help () {
        echo 'SYNTAX:'
        echo '  =base NUM TO [FROM=10]'
        echo '  echo NUM | =base TO [FROM=10]'
        echo '  =base TO [FROM=10] <<< "NUM"'
    } # }}}

    if (( $# <= 1 )); then
        echo -e "ERROR: Insufficient arguments. At least two required\n"; _help
        return 1
    fi

    if [[ -p /dev/stdin ]] || [[ -s /dev/stdin ]]; then
        # From pipe or from redirection respectively
        local _num=$(</dev/stdin)
    else
        local _num=$1
        shift
    fi

    local _obase=$1
    local _ibase=${2:-10}

    case $_ibase in
        2)  _num=${_num#0[bB]} ;;
        16) _num=$(tr '[a-f]' '[A-F]' <<< "${_num#0[xX]}") ;;
    esac

    local _result=$(echo "obase=$_obase; ibase=$_ibase; $_num" | bc)
    case $_obase in
        2)  _result="0b${_result}" ;;
        16) _result="0x${_result}" ;;
    esac

    echo $_result
)

=bin() { =base $1  2 ${2:-10}; }  # Convert to binary, by default from decimal
=dec() { =base $1 10 ${2:-16}; }  # Convert to decimal, by default from hexadecimal
=hex() { =base $1 16 ${2:-10}; }  # Convert to hexadecimal, by default from decimal

unset -f =slice
=slice() (
    _help() {
        echo 'SYNTAX:'
        echo '  =slice NUM MSB LSB'
        echo '  =slice NUM BIT'
        echo '  echo NUM | =slice MSB LSB'
        echo '  =slice MSB LSB <<< "NUM"'
        echo
        echo "NOTE: MSB >= LSB"
    }

    if (( $# >= 3 )); then
        local _num=$1
        shift
    elif [[ -p /dev/stdin ]] || [[ -s /dev/stdin ]]; then
        # From pipe or from redirection respectively
        local _num=$(</dev/stdin)
    elif (( $# < 1 )); then
        echo -e "ERROR: Insufficient arguments. At least one more required\n"; _help
        return 1
    else
        local _num=$1
        shift
    fi

    local _msb=$1
    local _lsb=${2:-$_msb}

    if (( $_lsb > $_msb )); then
        echo -e "ERROR: MSB must be greater than or equal to LSB when slicing\n"; _help
        return 1
    fi

    # echo "in=$_num, msb=$_msb, lsb=$_lsb"
    = "($_num >> $_lsb) & ((1 << ($_msb - $_lsb + 1)) - 1)"
)

# dir related
alias md='mkdir -p'

# Create new dir(s) and enter it (last directory if multiple arguments are given)
unset -f mcd
mcd() {
    command mkdir -p "$@" || return
    cd -- "${@: -1}"
}

# NOTE: The use of $* is deliberate here as it produces all the scripts arguments separated by the first character of
# $IFS which, by default, is a space. This allows me to match all arguments against a regex in one go instead of looping
# over them
dirs() {
    if (( $# == 0 )); then
        builtin dirs -v
    elif [[ "$*" =~ [-+][0-9]+ ]]; then
        # Use long-listing format. Without this, the home directory is display as '~' preventing me from doing something
        # like `cp $(dirs +1)` as it results in an error: pushd: ~/.vim: No such file or directory
        builtin dirs "$@" -l
    else
        builtin dirs "$@"
    fi
}

#=======================================================================================================================
# Silent pushd and uniquifies while pushing
# Note that `pushd` calls `cd` under the hood. So `cdable_vars` and `cdspell` apply to `pushd` as well
pushd() {
    builtin pushd "$@" > /dev/null;

    # Remove any duplicate entries. The 1st entry will be the PWD so skip it
    local _dir_pos=$(dirs -l -v | tail -n+2 | grep "$PWD$" | sed 's/^\s*//' | cut -d ' ' -f1 | paste -s)
    command popd -n +$_dir_pos &> /dev/null
}

# Better dirstack. Adds the following to the usual `cd` behavior:
# - `cd =`           Lists the contents of the stack and use fzf to select from it
# - `cd`             (with no args) Goes to $REPO_PATH if it's set. If not, or if already on $REPO_PATH, goes to $HOME
# - `cd ... [TARG]`  Jump to a directory in the path that starts with TARG.
#                  If TARG is not given, show all directories in the filepath and use fzf to select
cd() {
    if (( "$#" == 0 )); then
        if vcs::is_in_repo > /dev/null; then
            pushd "$(vcs::get_root)"
        else
            pushd "$HOME"
        fi
        return
    fi

    case "$1" in
        -)
            pushd
            return
            ;;

        =)
            if hash fzf 2> /dev/null; then
                $(FZF_ALT_C_COMMAND='command dirs -l -p' __fzf_cd__)
            else
                dirs
            fi
            return
            ;;

        ...)
            if hash fzf 2> /dev/null; then
                local _selected=$(_dir=$PWD;
                                  while [[ -n "$_dir" ]]; do
                                      _dir="${_dir%/[^/]*}";
                                      echo ${_dir:-/};
                                  done | fzf::_down --select-1 --delimiter='/' --nth=-1 ${2+ --query=$2})
                pushd $_selected
            fi
            return
            ;;

        *\*\**)
            # Split $1 about the first ** into '_path' and '_pattern' and replace all '**' in _pattern with '*'
            local _path=${1%%\*\**}; _path=${_path:-.}
            local _pattern="*$(tr -s '*' <<< ${1#*\*\*})"

            local _selected
            if hash fzf 2> /dev/null; then
                # Find '_path' for all dirs that match the glob expr '_pattern' and select with FZF from the results
                _selected=$(if hash fd 2> /dev/null; then
                                ${FZF_ALT_C_COMMAND} --full-path --glob "${_pattern}" "${_path}"
                            else
                                find "${_path}" -type d -path "${_pattern}"
                            fi | fzf::_down --select-1)
            else
                # Select only the first match since without FZF we don't have a good way of handling multiple matches
                if hash fd 2> /dev/null; then
                    _selected=$(fd --color=never --hidden --exclude .git --type d --glob "${_pattern}" ${_path} | head -n 1)
                else
                    _selected=$(find $_path -type d -path "${_pattern}" -print -quit)
                fi
            fi

            pushd "$_selected"
            return
            ;;
    esac

    # Fall-through to the default command
    pushd "$@"
}

alias ..='cd ..'

#=======================================================================================================================
# [[https://github.com/junegunn/fzf][fzf]]
if [[ -d /opt/fzf ]]; then
    export FZF_PATH=/opt/fzf
fi
source ${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/fzf/fzf.bash

#=======================================================================================================================
# zoxide (https://github.com/ajeetdsouza/zoxide)
if hash zoxide 2> /dev/null; then
  eval "$(zoxide init --cmd j bash)"
fi


# query
# =which= on steroids. Shows aliases and function definitions recursively.
# Since this function deals with aliases, it cannot be made into a stand-alone script since aliases are not accessible inside subshells.

query() (
# Yep, parentheses is correct. It makes this a subshell function allowing the definition to be inaccessible from outside
# Thus, no more polluting of shell space with helper functions

__help() {                                                                                                    # {{{1
  echo "Usage:"
  echo "    query [OPTION]... INPUT..."
  echo
  echo "INPUT can be one or more alias, file, command, function etc. but must be specified last"
  echo
  echo "Options:"
  echo "    -h, --help             Print this help"
  echo "        --ascii            Use ASCII instead of extended characters"
  echo "        --color            Colorize output"
  echo "        --nocolor          Don't colorize output"
  echo "    -d, --max-depth <N>    Recurse only N-levels deep. If N=0, query only the specified input"
  echo "        --nodefine         Don't print the function definition"
}

__parse_args() {                                                                                              # {{{1
  #echo "DEBUG: Parse:'$@'"

  # Default values of options
  _opts[ascii]=0
  _opts[color]=1
  _opts[define]=1
  _opts[depth]=-1
  _opts[input]=""
  _opts[level]=0

  local _i
  for _i in "$@"; do
    if [[ $_i =~ ^-h$ ]] || [[ $_i =~ ^--help$ ]]; then
      __help
      return 0
    fi
  done

  local _opt_end=false
  while (( $# > 0 )); do
    #echo "DEBUG: Arg:'$1'"
    case $1 in
      --?*)
        ;&
      -[[:alpha:]])
        if ! $_opt_end && [[ ! $1 =~ ^-l$ ]] && [[ ! $1 =~ ^--level$ ]]; then
          _cmd_recurse+=("$1")
        fi
        ;;&

      --ascii)
        _opts[ascii]=1
        ;;

      --color)
        _opts[color]=1
        ;;
      --nocolor)
        _opts[color]=0
        ;;

      --level|-l)
        # Internal use only. Should not be specified by the user
        shift
        if [[ ! $1 =~ ^[0-9]+$ ]]; then
          echo "ERROR: Current level must be a number"
          return 1;
        fi
        _opts[level]=$1
        ;;

      --max-depth|-d)
        shift
        if [[ ! $1 =~ ^[0-9]+$ ]]; then
          echo -e "ERROR: Max-depth must be a number\n"
          __help
          return 1;
        fi
        _opts[depth]=$1
        ;;

      --nodefine)
        #echo "Don't print function definition"
        _opts[define]=0
        ;;

      --)
        # Standard shell separator between options and arguments
        if ! $_opt_end; then
          _opt_end=true
        fi
        ;;

      -*)
        if ! $_opt_end; then
          echo -e "ERROR: Invalid option: '$1'"
          __help
          return 1;
        fi
        ;&

      *)
        # To support multiple inputs
        while (( $# > 1 )); do
          query ${_cmd_recurse[@]} --level 0 $1
          shift
          echo -e "\n"
        done
        _opts[input]=$1
        ;;
    esac
    shift
  done

  # If you don't give me something to work with, then what am I supposed to do?
  if [[ -z ${_opts[input]} ]]; then
    echo "ERROR: No input specified"
    return 1;
  fi
}

__query_alias() {                                                                                                   # {{{1
  echo "${_query_pp[sep]}${_query_pp[input]} (${_query_pp[type]})"
  while read; do
    echo "${_query_pp[spc]}${REPLY}";
  done < <(command type -a -- "${_opts[input]}" | command head -n2)

  # Recurse
  if (( ${_opts[depth]} == -1 )) || (( ${_query_opts[level]} < ${_query_opts[depth]} )); then
    local _out_arr=()
    read -a _out_arr <<< $(command type -a -- ${_opts[input]} | command grep -Po "(?<=aliased to .).*(?='$)")
    local _query_next=()
    local _level_next=$((${_opts[level]} + 1))
    _query_tree[$_level_next]=0

    local _i=0
    for _i in ${_out_arr[@]}; do
      if [[ "$_i" != "${_opts[input]}" ]]; then
        if [[ $(command type -t -- "$_i") =~ file|function|alias ]]; then
          _query_tree[$_level_next]=$(( ${_query_tree[$_level_next]} + 1 ))
          _query_next+=("$_i")
        fi
      fi
    done
    for _i in ${_query_next[@]}; do
      _query_tree[$_level_next]=$(( ${_query_tree[$_level_next]} - 1 ))
      query "${_cmd_recurse[@]}" --level $_level_next $_i
    done
  fi
}

__query_file() {                                                                                                    # {{{1
  echo "${_query_pp[sep]}${_query_pp[input]} (${_query_pp[type]})"
  while read; do
    echo "${_query_pp[spc]}${REPLY}";
  done < <(command type -a -- "${_opts[input]}" | command head -n1)
}

__query_function() {                                                                                                # {{{1
  echo "${_query_pp[sep]}${_query_pp[input]} (${_query_pp[type]})"
  shopt -s extdebug
  IFS=" " read -a _arr <<< $(command declare -F -- "${_opts[input]}")
  shopt -u extdebug
  echo -e "${_query_pp[spc]}Defined in ${_arr[2]} at line ${_arr[1]}"

  # Print the function definition
  if [[ "${_opts[define]}" == "1" ]]; then
    while read; do
      echo "${_query_pp[spc]}${REPLY}";
    done < <(command type -a -- "${_opts[input]}" | command tail -n+2)
  fi
}

__query_pp() {                                                                                                      # {{{1

  _query_pp[spc]=""
  _query_pp[sep]=""

  # Setup the tree-drawing characters
  if [[ "${_opts[ascii]}" == "1" ]]; then
    local _v_bar='|'
    local _h_bar='-'
    local _x_bar='+'
    local _xl_bar='\'
  else
    local _v_bar='│'
    local _h_bar='─'
    local _x_bar='├'
    local _xl_bar='└'
  fi
  _query_pp[xl]=${_query_pp[xl]:-$_x_bar}

  # Colorize the output?
  if [[ "${_opts[color]}" == "1" ]]; then
    local _c_type="$(tput setaf 4)"
    local _c_input="$(tput bold)$(tput setaf 2)"
    local _c_reset="$(tput sgr0)"
  else
    local _c_type=""
    local _c_input=""
    local _c_reset=""
  fi

  if [[ "${_opts[level]}" != "0" ]]; then
    local _i=0
    for (( _i=1; _i <= ${_opts[level]}; _i++ )); do
      #echo ${_query_tree[$_i]}
      if (( ${_query_tree[$_i]} > 0 )); then
        _query_pp[spc]="${_query_pp[spc]}${_v_bar}   "
      else
        _query_pp[spc]="${_query_pp[spc]}    "
      fi
    done
    if (( ${_query_tree[${_opts[level]}]} == 0 )); then
      _x_bar=$_xl_bar
    fi
    _query_pp[sep]="${_query_pp[spc]%????}${_x_bar}${_h_bar}${_h_bar} "
    echo "${_query_pp[spc]%????}${_v_bar}"
  fi

  _query_pp[type]="${_c_type}${_type}${_c_reset}"
  _query_pp[input]="${_c_input}${_opts[input]}${_c_reset}"
}
# }}}1

  #echo "DEBUG: Cmd='$@'"
  # Default values for options
  local -A _opts=()
  local -a _cmd_recurse=()
  __parse_args "$@"
  local _ret_val=$?
  if [[ "$_ret_val" != "0" ]]; then
    return $_ret_val;
  fi

  local _type=$(command type -t -- "${_opts[input]}")
  #echo "DEBUG: Input='${_opts[input]}', Type='$_type'"

  # Pretty-print the tree structure for recursive lookups
  local -A _query_pp=()
  if (( ${_opts[level]} == 0 )); then
    echo
    local -a _query_tree=()
  fi
  __query_pp

  case $_type in
    "file")
      __query_file
      ;;
    "function")
      __query_function
      ;;
    "alias")
      __query_alias
      ;;
    *)
      command type -a -- "${_opts[input]}"
      ;;
  esac
)

alias que=query

#=======================================================================================================================
# Collection of utilities to deal with all VCS related stuff
vcs::is_in_git_repo() {
    local _cwd=$PWD
    if (( $# > 0 )); then
        command cd $1
    fi

    git rev-parse HEAD &> /dev/null
    local _ret=$?

    if (( $# > 0 )); then
        command cd $_cwd
    fi

    return $_ret
}

vcs::is_in_perforce_repo() {
    [[ -n "$STEM" ]] && [[ ${1-$PWD} =~ $STEM ]];
}

vcs::is_in_repo() {
    vcs::is_in_git_repo "$@" || vcs::is_in_perforce_repo "$@"
}

vcs::get_p4_branch() {
  local top=${REPO_PATH-$PWD}
  if [[ -f "$top/configuration_id" ]]; then
    echo "$(sed 's/@.*//' "$top/configuration_id" 2> /dev/null)"
  fi
}
vcs::get_branch() {
    # Description: If PWD is under a VCS, return the branch. If not, return an empty string

    if vcs::is_in_git_repo; then
        # echo "DEBUG: VCS Type=$_vcs_type (vcs::get_branch)"
        git symbolic-ref --short HEAD 2> /dev/null
    elif vcs::is_in_perforce_repo; then
        # echo "DEBUG: VCS Type=$_vcs_type (vcs::get_branch)"
        vcs::get_p4_branch
    else
        echo ""
    fi
}

vcs::get_status() {
    # Description: Get the status of the VCS - works only for git at the moment

    if vcs::is_in_git_repo; then
        local _vcs_branch=$(vcs::get_branch)
        if $(echo "$(git log origin/$_vcs_branch..HEAD 2> /dev/null)" | grep '^commit' &> /dev/null); then
            echo "staged"
        elif [[ -n $(git status -s --ignore-submodules=dirty  2> /dev/null) ]]; then
            echo "modified"
        else
            echo "committed"
        fi
    fi
}

vcs::get_root() {
    if vcs::is_in_git_repo "$@"; then
        echo "$(git rev-parse --show-toplevel)"
    elif vcs::is_in_perforce_repo "$@"; then
        echo "$REPO_PATH"
    else
        echo ""
    fi
}

# Now, if I run =g SOMETHING= followed by =vq= then =vq= doesn't run as expected because ~!!~ expands to 'g SOMETHING'.
# However, in the expanded form, 'g' doesn't get replaced with grep because of the afore-mentioned limitation.

# To avoid this, I use functions for my most commonly used aliases so that they work everywhere and, aliases only if I'm sure that they won't be used in the middle of a command.

alias ls='ls -FLH --color=always'
alias l=ls
alias la='ls -A'
alias ll='ls -lh'
alias lla='ll -A'

alias c=clear
alias cl="c;l"

#alias echo '\echo -e'
#alias lock='/usr/local/bin/xlock'
alias mv='mv -vi'
alias cp='cp -vi'
alias rm='rm -vi'
alias rd='rm -rvf'
alias ln='ln -svi'
alias df='df -h'
alias pppath='tr ":" "\n" <<< $PATH'
alias clnpath='export PATH=$(tr ":" "\n" <<< $PATH | perl -ne "print unless \$seen{\$_}++" | paste -s -d":")'

if command -v bat >/dev/null 2>&1; then
  alias C="bat --paging=never"
else
  alias C=cat
fi
alias P=$PAGER
alias hh='history | tail'
alias x=exit
alias pls='sudo $(history -p !!)'
duh() { du -h "$@" | sort -rh; }

ec() { emacsclient --alternate-editor="" --no-wait --create-frame --quiet "$@" & }
alias e=ec
alias evan='emacs --with-profile vanilla'

# From https://askubuntu.com/a/185746/38952
# Using ww twice ensures that the output is not truncated to the width of the terminal

psgrep() { ps wwup $(command pgrep -f "$@"); }

# bookmarks for commonly used config files

alias gosc='$VISUAL ~/.bashrc'
alias gost='$VISUAL ~/.dotfiles/tmux/tmux.conf'
alias gosx='$VISUAL ~/.Xresources'
alias sosc='. ~/.bashrc && clnpath'


# grep

export GREP_COLORS='1;32'
alias grep='grep -sP --color=always'

# I use ~g~ as a generic alias for grep and all its replacements. Hence create a generic alias

alias g=grep
alias gi='g -i'
alias gv='g -v'


# git

alias ga='git add'
alias gA='git add -A .'
alias gh='git help'
alias gs='git status'


# perforce

alias pf='p4'
alias pfd='pf diff'
alias pfdg='P4DIFF= pf diff -du | grepdiff --output-matching=hunk --remove-timestamps'
alias pfe='pf edit'
alias pflog='pf filelog -stl -m 5'

# Make opened files prettier by aligning the columns

pfo() {
    pf opened "$@" | command column -s# -o ' #' -t | command column -o ' ' -t | command sed 's/#/   #/'
}

pfrel() {
    if [[ ! -t 0 ]]; then
        pf where $(command sed -e 's/#.*//' < /dev/stdin)
    elif [[ -n "$1" ]]; then
        pf where $(command sed -e 's/#.*//' "$@")
    else
        return
    fi |  awk "{ if (\$3 != \"$REPO_PATH/...\") { print \$3; } }" | sed -e "s:$REPO_PATH/::"
}

pfor() {
    pfo "$@" | pfrel
}

# Show top N (default=10) changes

pftop() {
    local num=10
    if (( $# > 0 )) && [[ "$1" =~ ^[0-9]+$ ]]; then
        num=$1
        shift
    fi
    pf changes -m $num "$@" $STEM/...
}


# rm
# Delete in background

unset -f rm_rf
rm_rf_silent() {
    # FIXME: Doesn't work if there are spaces in the filename
    for i in "$@"; do
        # Remove trailing slash and move to hidden
        ni=${i/%\//}
        bi=$(basename $ni)
        ni=${ni/%$bi/.$bi}

        #echo $ni.$$
        command mv $i $ni.$$
        command rm -rf $ni.$$ &
    done
}
alias rdj='rm_rf_silent'

# [[https://github.com/BurntSushi/ripgrep][ripgrep]]
# These will be tangled only if =rg= exists

export RIPGREP_CONFIG_PATH=${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/ripgrep/config
alias g='command rg'


# vim/neovim

alias v=$EDITOR
if [[ $EDITOR == "nvim" ]]; then
  alias vi='nvim --clean'
else
  alias vi="vim -u NORC -U NORC -N --cmd 'set rtp="'$VIM,$VIMRUNTIME,$VIM/after'"'"
fi

# Open results of the last shell command in vim quickfix.
# Very useful for searching something using =rg= etc. and iterating through the results in vim

vq() { v -q <(eval "$(fc -nl -1) $@"); }
vqg() { v -q <(g --vimgrep "$@"); }

# Opening up vimdiff takes noticeable amount of time. This will run it only if required.
# Using -f keeps the window in the foreground and prevents a whole bunch of diffs opening at the same time

gvim_diff() {
    # Check to see if all files are present. If not, return.
    for i in "$@"; do
        [[ ! -f "$i" ]] && return
    done

    # If there are no differences, print that files are identical and return
    command diff -qs "$@" && return

    # Run vimdiff only if there are differences and all files are present
    gvim -df -c 'set nobackup' "$@"
}
alias vd=gvim_diff

# [[https://github.com/tmux/tmux][tmux]]

source ${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/tmux/tmuxw.bash
alias tmux='tmuxw'
alias tm='tmux'


# PATH

if ((which ruby &> /dev/null) && (which gem &> /dev/null)); then
  export PATH="$(ruby -rubygems -e 'puts Gem.user_dir')/bin:$PATH"
fi
export PATH="$HOME/.local/bin:$PATH"
clnpath


## prompt
# 'PROMPT_COMMAND' is evaluated right before the prompt is displayed. I use it to update history more regularly
PROMPT_COMMAND=__setprompt

__setprompt() {
  # Set HISTFILE here to keep it current when sessions span multiple days
  # FIXME: Find a better way to do this i.e. do it once a day instead of everytime the prompt is refreshed
  HISTFILE="${XDG_DATA_HOME:-$HOME/.local/share}/bash_history/$(date +%Y/%m/%d)_${HOSTNAME%%.*}_${USER}_$$"
  [[ -d $(dirname ${HISTFILE}) ]] || mkdir -p $(dirname ${HISTFILE})

  # Write to the history file immediately instead of waiting till the end of the session
  history -a
}

# Use the starship prompt
eval "$(starship init bash)"


# local override
# Update permissions of the history when exiting as root

__histfile_perm_update__() {
    if [[ -f $HISTFILE ]]; then
        echo "Changing permissions of HISTFILE..."
        chown kshenoy $HISTFILE
        chgrp kshenoy $HISTFILE
        chmod 640 $HISTFILE
    fi
}
trap __histfile_perm_update__ EXIT

## When leaving the console, clear the screen to increase privacy
if [[ "$SHLVL" = 1 ]]; then
    [[ -x /usr/bin/clear_console ]] && /usr/bin/clear_console -q
fi


# bashrc_local
# And finally, check for a .bashrc_local and load it

[[ -f ~/.bashrc_local_override ]] && . ~/.bashrc_local_override


# command completion

if [[ -f /etc/bash_completion ]] && ! shopt -oq posix; then
    . /etc/bash_completion
fi

complete -A hostname   rsh rcp telnet rlogin r ftp ping disk
complete -A export     printenv
complete -A variable   export local readonly unset
complete -A enabled    builtin
complete -A alias      alias unalias
complete -A function   function
complete -A user       su mail finger

complete -A helptopic  help     # currently same as builtins
complete -A shopt      shopt
complete -A stopped -P '%' bg
complete -A job -P '%' fg jobs disown

complete -A directory  mkdir rmdir
complete -A directory  -o default cd

# Compression
complete -f -o default -X '*.+(zip|ZIP)'  zip
complete -f -o default -X '!*.+(zip|ZIP)' unzip
complete -f -o default -X '*.+(z|Z)'      compress
complete -f -o default -X '!*.+(z|Z)'     uncompress
complete -f -o default -X '*.+(gz|GZ)'    gzip
complete -f -o default -X '!*.+(gz|GZ)'   gunzip
complete -f -o default -X '*.+(bz2|BZ2)'  bzip2
complete -f -o default -X '!*.+(bz2|BZ2)' bunzip2

# Misc filetypes
complete -f -o default -X '!*.ps'  gs ghostview ps2pdf ps2ascii
complete -f -o default -X '!*.dvi' dvips dvipdf xdvi dviselect dvitype
complete -f -o default -X '!*.pdf' acroread pdf2ps
complete -f -o default -X '!*.+(pdf|ps)' gv
complete -f -o default -X '!*.texi*' makeinfo texi2dvi texi2html texi2pdf
complete -f -o default -X '!*.tex' tex latex slitex
complete -f -o default -X '!*.lyx' lyx
complete -f -o default -X '!*.+(htm*|HTM*)' lynx html2ps
complete -f -o default -X '!*.pl'  perl perl5
complete -f -o default -X '!*.gv'   dot
complete -f -o default -X '!*.gif'  kview

# Multimedia
#complete -f -o default -X '!*.+(jp*g|gif|xpm|png|bmp)' xv gimp
#complete -f -o default -X '!*.+(mp3|MP3)' mpg123 mpg321
#complete -f -o default -X '!*.+(ogg|OGG)' ogg123


# fzf completion
# Rest of fzf configuration defined above: [[*\[\[https://github.com/junegunn/fzf\]\[fzf\]\]][fzf]]

[[ $- == *i* ]] && source "$FZF_PATH/shell/completion.bash" 2> /dev/null


# alias completion
# Automatically add completion for all aliases to commands having completion functions
# This must be called only at the very end

_compl_alias() {
    [[ -z "$1" ]] && return
    local _alias="$1"

    if (( $# >= 2 )); then
        local _cmd="$2"
    else
        local _cmd="$(alias $_alias 2> /dev/null | sed -e 's/^.*=//' -e 's/ .*$//' | tr -d "'")"
    fi
    [[ -z "$_cmd" ]] && return

    eval "$(complete -p $_cmd | sed "s/$_cmd$/$_alias/")"
}

# Note the order of application is important

_compl_alias e    emacs
_compl_alias g    grep
_compl_alias v    nvim
_compl_alias vd   diff
_compl_alias vile less
_compl_alias C    cat
_compl_alias bat  cat
for _alias in P gi gv l la ll lla doomacs; do
    _compl_alias "$_alias"
done

. ~/.bash_ai
