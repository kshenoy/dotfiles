#========================================================================================================================
# BASH CONFIGURATION
#========================================================================================================================
# NOTE: exporting a variable makes it available for child processes via the environment

# Proceed only if its an interactive shell
[[ $- == *i* ]] || return

#========================================================================================================================
# LOCAL INITIALIZATION
#========================================================================================================================
# Any local settings that need to be set initially go here
[[ -f ~/.bashrc_local_init ]] && . ~/.bashrc_local_init

#========================================================================================================================
# SHELL OPTIONS & TTY SETTINGS
#========================================================================================================================
# Turn off TTY "start" and "stop" commands in all interactive shells.
# They default to ~C-q~ and ~C-s~. I want to use ~C-s~ to do forward history search.
stty start ''
stty stop  ''
stty -ixon # disable XON/XOFF flow control
stty ixoff # enable sending (to app) of start/stop characters
stty ixany # let any character restart output, not only start character

# default permissions
umask 002

# See: https://unix.stackexchange.com/questions/32409/set-and-shopt-why-two
# Using shopt: https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html
# -s : set
# -u : unset
# -q : query whether set/unset
# List of shell options: http://wiki.bash-hackers.org/internals/shell_options

# Directory and completion options
shopt -s cdable_vars  # Allow cd to variable names containing directory paths
shopt -s cdspell      # Auto-correct minor typos in directory names
shopt -s checkhash    # Check if hashed commands still exist before executing
shopt -s checkjobs    # List stopped/running jobs before exiting shell
shopt -s checkwinsize # Update LINES and COLUMNS after each command
shopt -s direxpand    # Expand directory names (prevents escaping $ in $dir_variable)
shopt -s dirspell     # Auto-correct directory names during completion
shopt -s dotglob      # Include hidden files in filename expansion
shopt -s huponexit     # Send SIGHUP to jobs when interactive login shell exits
shopt -s lastpipe      # Run last command of pipeline in current shell
shopt -s lithist       # Save multi-line commands with embedded newlines
shopt -s mailwarn      # Warn if mail file has been accessed
shopt -s shift_verbose # Print error when shift count exceeds parameters

set -o noclobber
set bell-style none
set +o nounset  # Otherwise some completions will fail

#========================================================================================================================
# HISTORY CONFIGURATION
#========================================================================================================================
shopt -s histappend    # Append to history file instead of overwriting
shopt -s histreedit    # Allow re-editing failed history substitutions
shopt -s histverify    # Load history substitutions into readline buffer for confirmation

# Increase size of history in the terminal. Default is a measly 512 lines
export HISTSIZE=65535
export HISTFILESIZE=65535

# Add timestamps to history
export HISTTIMEFORMAT="%F %T  "

# Ignore duplicates and trivial one/two char commands as I've a bad habit of doing =cl= all the time.
export HISTIGNORE='?:??:history*:sosc:que*:ll*'

# ignoredups:  ignore duplicate commands entered consecutively
# ignorespace: don't log commands that start with a space
# ignoreboth:  ignoredups + ignorespace
export HISTCONTROL=ignoreboth

#========================================================================================================================
# ENVIRONMENT VARIABLES
#========================================================================================================================
export EDITOR=nvim
export VISUAL=gvim

# Make less more friendly for non-text input files, see lesspipe(1)
export MANPAGER=less
export PAGER=less
[[ -x /usr/bin/lesspipe ]] && eval "$(SHELL=/bin/sh lesspipe)"

export HOSTNAME="$(hostname)"
export LANG=en_US.UTF-8

#========================================================================================================================
# COLORS & PAGER CONFIGURATION
#========================================================================================================================
# ls colors
if [[ -x /usr/bin/dircolors ]]; then
    _dircolors=${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/bash/dircolors.rc
    [[ -r $_dircolors ]] && eval "$(/usr/bin/dircolors -b $_dircolors)" || eval "$(/usr/bin/dircolors -b)"
fi

# colored man pages with less
man() {
    env \
        LESS_TERMCAP_mb=$(printf "\e[1;31m") \
        LESS_TERMCAP_md=$(printf "\e[1;31m") \
        LESS_TERMCAP_me=$(printf "\e[0m") \
        LESS_TERMCAP_se=$(printf "\e[0m") \
        LESS_TERMCAP_so=$(printf "\e[0;43;30m") \
        LESS_TERMCAP_ue=$(printf "\e[0m") \
        LESS_TERMCAP_us=$(printf "\e[1;32m") \
        man "$@"
}

#========================================================================================================================
# DIRECTORY NAVIGATION
#========================================================================================================================

# Function: dirs
# Description: Enhanced directory stack viewer
# Usage:
#   dirs        - List directory stack
#   dirs +N/-N  - Show specific entry (uses long format to avoid ~ expansion)
dirs() {
    if (( $# == 0 )); then
        builtin dirs -v
    elif [[ "$*" =~ [-+][0-9]+ ]]; then
        # Use long-listing format. Without this, the home directory is display as '~' preventing me from doing something
        # like `cp $(dirs +1)` as it results in an error: pushd: ~/.vim: No such file or directory
        builtin dirs "$@" -l
    else
        builtin dirs "$@"
    fi
}

# Function: pushd
# Description: Silent pushd that removes duplicate entries from directory stack
# Note: pushd calls cd under the hood, so cdable_vars and cdspell apply here too
pushd() {
    builtin pushd "$@" > /dev/null;

    # Remove any duplicate entries. The 1st entry will be the PWD so skip it
    local _dir_pos=$(dirs -l -v | tail -n+2 | grep "$PWD$" | sed 's/^\s*//' | cut -d ' ' -f1 | paste -s)
    command popd -n +$_dir_pos &> /dev/null
}

# Function: cd
# Description: Enhanced cd with fuzzy directory navigation
# Usage:
#   cd              - Go to repository root (if in repo) or $HOME
#   cd =            - Select from directory stack with fzf
#   cd ... [TARG]   - Navigate up directory tree with fzf, optionally filtered by TARG
#   cd path**glob   - Fuzzy search subdirectories matching glob pattern
cd() {
    if (( "$#" == 0 )); then
        if vcs::is_in_repo > /dev/null; then
            pushd "$(vcs::get_root)"
        else
            pushd "$HOME"
        fi
        return
    fi

    case "$1" in
        -)
            pushd
            return
            ;;

        =)
            if hash fzf 2> /dev/null; then
                $(FZF_ALT_C_COMMAND='command dirs -l -p' __fzf_cd__)
            else
                dirs
            fi
            return
            ;;

        ...)
            if hash fzf 2> /dev/null; then
                local _selected=$(_dir=$PWD;
                                  while [[ -n "$_dir" ]]; do
                                      _dir="${_dir%/[^/]*}";
                                      echo ${_dir:-/};
                                  done | fzf::_down --select-1 --delimiter='/' --nth=-1 ${2+ --query=$2})
                pushd $_selected
            fi
            return
            ;;

        *\*\**)
            # Split $1 about the first ** into '_path' and '_pattern' and replace all '**' in _pattern with '*'
            local _path=${1%%\*\**}; _path=${_path:-.}
            local _pattern="*$(tr -s '*' <<< ${1#*\*\*})"

            local _selected
            if hash fzf 2> /dev/null; then
                # Find '_path' for all dirs that match the glob expr '_pattern' and select with FZF from the results
                _selected=$(if hash fd 2> /dev/null; then
                                ${FZF_ALT_C_COMMAND} --full-path --glob "${_pattern}" "${_path}"
                            else
                                find "${_path}" -type d -path "${_pattern}"
                            fi | fzf::_down --select-1)
            else
                # Select only the first match since without FZF we don't have a good way of handling multiple matches
                if hash fd 2> /dev/null; then
                    _selected=$(fd --color=never --hidden --exclude .git --type d --glob "${_pattern}" ${_path} | head -n 1)
                else
                    _selected=$(find $_path -type d -path "${_pattern}" -print -quit)
                fi
            fi

            pushd "$_selected"
            return
            ;;
    esac

    # Fall-through to the default command
    pushd "$@"
}

alias ..='cd ..'

#========================================================================================================================
# EXTERNAL TOOL INTEGRATIONS
#========================================================================================================================

# fzf: https://github.com/junegunn/fzf
if [[ -d /opt/fzf ]]; then
    export FZF_PATH=/opt/fzf
fi
source ${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/fzf/fzf.bash

# zoxide (https://github.com/ajeetdsouza/zoxide)
if hash zoxide 2> /dev/null; then
  eval "$(zoxide init --cmd j bash)"
fi

#========================================================================================================================
# MODULAR CONFIGURATION
#========================================================================================================================
# Load modular configuration files
[[ -f utils/calc.sh ]] && . utils/calc.sh
[[ -f utils/query.sh ]] && . utils/query.sh
[[ -f vcs.sh ]] && . vcs.sh
[[ -f aliases.sh ]] && . aliases.sh

#========================================================================================================================
# PATH MANAGEMENT
#========================================================================================================================
if ((which ruby &> /dev/null) && (which gem &> /dev/null)); then
  export PATH="$(ruby -rubygems -e 'puts Gem.user_dir')/bin:$PATH"
fi
export PATH="$HOME/.local/bin:$PATH"
clnpath

#========================================================================================================================
# PROMPT & COMPLETION
#========================================================================================================================
# Load prompt configuration and completions
[[ -f prompt.sh ]] && . prompt.sh
[[ -f completions.sh ]] && . completions.sh

# Local overrides (loaded last)
[[ -f ~/.bashrc_local_override ]] && . ~/.bashrc_local_override

# AI integration
[[ -f ~/.bash_ai ]] && . ~/.bash_ai
