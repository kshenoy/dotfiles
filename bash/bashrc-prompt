#!/bin/bash -f
#=======================================================================================================================
# Helper
#=======================================================================================================================
# Foreground/Background Color Codes
  # 30/40 : black
  # 31/41 : red
  # 32/42 : green
  # 33/43 : yellow
  # 34/44 : blue
  # 35/45 : magenta
  # 36/46 : cyan
  # 37/47 : white
#
# Attribute Codes
  #  0 : Normal
  #  1 : Bold
  #  2 : Normal
  #  3 : Italics*
  #  4 : Underline
  #  5 : Blink
  #  6 : Outline
  #  7 : Reverse FG and BG Colors
  #  8 : Invisible (FG color is made same as BG)
  #  9 : Strike-out*
  # 22 : Bold Off
  # 23 : Italics Off
  # 24 : Underline Off
  # 25 : Blink Off
  # 27 : Reverse Off
  # 29 : Strike-out Off
#
# Always use tput to generate these codes.
echo "$(tput setaf 2)Sourcing$(tput sgr0) ${BASH_SOURCE[0]} ..."

# This should always point to whatever prompt is desired.
PROMPT_COMMAND=__setprompt


#=======================================================================================================================
# Mod of SJL's prompt
#  SJL's Prompt
#  Credit for ideas/info: Phil!'s ZSH Prompt, Bashish, TERMWIDE prompt
#                         Bash Prompt Howto
#                         http://stevelosh.com/blog/2010/02/my-extravagant-zsh-prompt/
#
# Example:
# ┌ kshenoy @ svvgar-nx16 in ~/.vim ───────────────────── 03:57pm Aug 02, Fri
# └ (^_^) ➤
#
##### code ####
## Use bash builtin checkwinsize option for terminals which fail to properly
## set the $COLUMNS variable. (bug workaround)
shopt -s checkwinsize

## This function is run at every prompt update, keeping our variables updated.
## Bash's PROMPT_COMMAND option handles this (see end of this function).
__setprompt() {

  # This has to be placed first
  local _exit_status="$?"

  # We use this instead of $COLUMNS as when a shell is starting, the $COLUMNS variable is not set
  local _columns=$(tput cols)

  # Colors
  # NOTE: Non-printable sequences should be enclosed in \[ and \] else it'll cause long commands to not wrap correctly
  local _reset="\[$(tput sgr0)\]"
  local _bold="\[$(tput bold)\]"
  local _fg_black="\[$(tput setaf 0)\]"
  local _fg_light_black="\[$(tput setaf 8)\]"
  local _fg_red="\[$(tput setaf 1)\]"
  local _fg_yellow="\[$(tput setaf 3)\]"
  local _fg_green="\[$(tput setaf 2)\]"
  local _fg_blue="\[$(tput setaf 4)\]"
  local _fg_purple="\[$(tput setaf 5)\]"

  # Set line graphics
  local _dash="─"
  local _ulcorner="┌"
  # local _ulcorner="╭"
  local _llcorner="└"
  # local _llcorner="╰"

  # If root user then colour the arrow red.
  if (( "${UID}" == 0 )); then
    local _fg_user_symbol=${_fg_red}
  else
    local _fg_user_symbol=${_bold}${_fg_light_black}
  fi

  # The info variables
  local _pwd=$(prompt::get_compact_pwd)

  #for k in "${!dir_alias[@]}"; do
    #echo "$k => ${dir_alias[$k]}"
    #echo ${_pwd/#$k/${dir_alias[$k]}}
  #done
  #for i in ${!dir_alias[@]}; do
  #  [ -n "$i" ] && _pwd=${_pwd/#$i/${dir_alias[$i]}}
  #done

  # Force time to US Mountain Time (we do this here as well as in .bashrc as sourcing some env files overwrites this)
  local _time="$(TZ=US/Mountain date +%I:%M%P) "
  local _user="$(whoami) "
  local _user_host_sep="@ "
  local _pwd_sep="in "
  local _host="$(hostname) "

  # VCS specific
  local _vcs_type=$(vcs::get_type)
  local _vcs_branch=$(vcs::get_branch ${_vcs_type})
  local _vcs_sep=" on "

  if [[ $_vcs_type == "git" ]]; then
    local _user_symbol=" ±"
  elif [[ $_vcs_type == "hg" ]]; then
    local _user_symbol=" ☿"
  elif [[ $_vcs_type == "p4" ]]; then
    local _vcs_sep=" on "
  else
    #local _user_symbol=" ○"
    #local _user_symbol=" ➤"
    local _user_symbol=" $"
    local _vcs_sep=""
  fi

  # Set length of info
  _info="${_ulcorner} ${_user}${_user_host_sep}${_host}${_pwd_sep}${_pwd}${_vcs_sep}${_vcs_branch} ${_time}"

  # If info is wider than the screen, drop the time
  if (( $_columns < ${#_info} )); then
    _time=""
    _info="${_ulcorner} ${_user}${_user_host_sep}${_host}${_pwd_sep}${_pwd}${_vcs_sep}${_vcs_branch} "
  fi
  _pwd_sep="${_fg_light_black}${_pwd_sep}${_reset}"

  # If the info still can't fit, drop user and domain info
  if (( $_columns < ${#_info} )); then
    _user=""
    _user_host_sep=""
    _host=""
    _pwd_sep=""
    _info="${_ulcorner} ${_pwd}${_vcs_sep}${_vcs_branch} "
  fi

  # If the info still can't fit, drop vcs branch
  if (( $_columns < ${#_info} )); then
    _vcs_sep=""
    _vcs_branch=""
    _info="${_ulcorner} ${_pwd} "
  fi

  # If the info still can't fit, truncate PWD
  if (( $_columns < ${#_info} )); then
    _pwd_sep="..."
    while (( $_columns < ${#_info} )); do
      _pwd=`echo $_pwd | sed 's|^/\?[^/]*/||'`
      _info="${_ulcorner} ${_pwd_sep}${_pwd} "
    done
    _pwd_sep="${_bold}${_fg_green}${_pwd_sep}${_reset}"
  fi

  local _fillsize=$(( $_columns - ${#_info} - 1 ))
  local _fill=$(printf "${_dash}%.0s" $(seq 1 $_fillsize))" "

  # Colorize vcs:
  if [[ $_vcs_type == "git" ]]; then
    local _vcs_status=$(vcs::get_status ${_vcs_type} ${_vcs_branch})
    if [[ "${_vcs_status}" == "staged" ]]; then
      _vcs_branch="${_fg_yellow}${_vcs_branch}${_reset}"
    elif [[ "${_vcs_status}" == "modified" ]]; then
      _vcs_branch="${_fg_red}${_vcs_branch}${_reset}"
    elif [[ "${_vcs_status}" == "committed" ]]; then
      _vcs_branch="${_bold}${_fg_green}${_vcs_branch}${_reset}"
    fi
  elif [[ $_vcs_type == "p4" ]]; then
    _vcs_branch="${_fg_blue}${_vcs_branch}${_reset}"
  fi

  # Create exit status indicator based on exit status of last command
  if (( "$_exit_status" == 0 )); then
    _exit_status="${_bold}${_fg_green} (^_^)"
  else
    _exit_status="${_fg_red} (@_@)"
  fi

  PS1="\n${_reset}"
  PS1+="${_fg_light_black}${_ulcorner}${_reset} "
  PS1+="${_fg_red}${_user}${_reset}"
  PS1+="${_fg_light_black}${_user_host_sep}${_reset}"
  PS1+="${_fg_yellow}${_host}${_reset}"
  PS1+="${_pwd_sep}"
  PS1+="${_bold}${_fg_green}${_pwd}${_reset}"
  PS1+="${_fg_light_black}${_vcs_sep}${_reset}"
  PS1+="${_vcs_branch} "
  PS1+="${_fg_light_black}${_fill}${_reset}"
  PS1+="${_fg_yellow}${_time}${_reset}"
  PS1+="\n"
  PS1+="${_fg_light_black}${_llcorner}${_reset}"
  PS1+="${_exit_status}${_reset}"
  PS1+="${_fg_user_symbol}${_user_symbol}${_reset} "

  PS2="      ${_fg_user_symbol}...${_reset}   "

  # Evaluate dynamic variables only if dyn_vars is defined (Not required for prompt)
  declare -F dyn_vars &> /dev/null && dyn_vars

  # Putting this here to keep the HISTFILE current when sessions span multiple days
  # FIXME: Find a better way to do this i.e. do it once a day instead of everytime the prompt is refreshed
  HISTFILE="${XDG_DATA_HOME:-$HOME/.local/share}/bash_history/$(date +%Y/%m/%d)_${HOSTNAME%%.*}_${USER}_$$"
  [[ -d $(dirname ${HISTFILE}) ]] || mkdir -p $(dirname ${HISTFILE})
  # Write to the history file immediately instead of waiting till the end of the session
  history -a
}


#=======================================================================================================================
# Helper functions
#=======================================================================================================================
prompt::get_compact_pwd() {
  local _pwd=${PWD}
  if [[ "$_pwd" =~ ^"$HOME" ]]; then
    _pwd=${_pwd/#$HOME/\~};
  fi
  echo $_pwd
}
