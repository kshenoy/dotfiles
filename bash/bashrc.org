#+TITLE: bash configuration
#+PROPERTY: header-args+ :results output silent :noweb tangle :comments both :mkdirp yes

* bashrc
:PROPERTIES:
:header-args+: :tangle (concat (getenv "HOME") "/.bashrc")
:END:

#+begin_src bash :export none
# This is a tangled file. Do not make any changes here. All changes should preferably be made in the original Org file.
# Use =org-babel-tangle-jump-to-org= to jump back to it from any code block.
# If any changes are made here, use =org-babel-detangle= to add it back to the original Org mode file.
#+end_src

How to check for login v/s interactive shell
#+begin_src bash :tangle no
shopt -q login_shell && echo "Login shell" || echo "Not a login shell"
[[ $- == *i* ]] && echo "This is an interactive shell" || echo "This is a script"
#+end_src

Proceed only if its an interactive shell
#+begin_src bash
[[ $- == *i* ]] || return
#+end_src

** local init
Any local settings that need to be set initially go here
#+begin_src bash
[[ -f ~/.bashrc_local_init ]] && . ~/.bashrc_local_init
#+end_src

** interactive, login shell settings
Turn off TTY "start" and "stop" commands in all interactive shells.
They default to ~C-q~ and ~C-s~. I want to use ~C-s~ to do forward history search.
#+begin_src bash
stty start ''
stty stop  ''
stty -ixon # disable XON/XOFF flow control
stty ixoff # enable sending (to app) of start/stop characters
stty ixany # let any character restart output, not only start character
#+end_src

** configuration
default permissions
#+begin_src bash
umask 002
#+end_src

[[https://unix.stackexchange.com/questions/32409/set-and-shopt-why-two][shopt v/s set]]

Using [[https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html][shopt]]:
~-s~ : set
~-u~ : unset
~-q~ : query whether set/unset

[[http://wiki.bash-hackers.org/internals/shell_options][List of shell options]]

If set, a command name that is the name of a directory is executed as if it were the argument to the cd command.
#+begin_src bash
shopt -u autocd
#+end_src

If this is set, an argument to the cd builtin command that is not a directory is assumed to be the name of a variable whose value is the directory to change to.
#+begin_src bash
shopt -s cdable_vars
#+end_src

If set, minor errors in the spelling of a directory component in a cd command will be corrected.
The errors checked for are transposed characters, a missing character, and a character too many.
If a correction is found, the corrected path is printed, and the command proceeds.
#+begin_src bash
shopt -s cdspell
#+end_src

If this is set, Bash checks that a command found in the hash table exists before trying to execute it.
If a hashed command no longer exists, a normal path search is performed.
#+begin_src bash
shopt -s checkhash
#+end_src

If set, Bash lists the status of any stopped and running jobs before exiting an interactive shell.
If any jobs are running, this causes the exit to be deferred until a second exit is attempted without an intervening command (see Job Control).
The shell always postpones exiting if any jobs are stopped.
#+begin_src bash
shopt -s checkjobs
#+end_src

If set, Bash checks the window size after each command and, if necessary, updates the values of LINES and COLUMNS.
#+begin_src bash
shopt -s checkwinsize
#+end_src

If set, Bash attempts to save all lines of a multiple-line command in the same history entry.
#+begin_src bash
shopt -s cmdhist
#+end_src

If set, Bash quotes all shell metacharacters in filenames and directory names when performing completion.
If not set, Bash removes metacharacters such as the dollar sign from the set of characters that will be quoted in completed filenames when these metacharacters appear in shell variable references in words to be completed.
This means that dollar signs in variable names that expand to directories will not be quoted; however, any dollar signs appearing in filenames will not be quoted, either.
This is active only when bash is using backslashes to quote completed filenames.
#+begin_src bash
shopt -s complete_fullquote
#+end_src

If set, Bash replaces directory names with the results of word expansion when performing filename completion.
This changes the contents of the readline editing buffer. If not set, Bash attempts to preserve what the user typed.
I use it mainly to prevent bash from escaping $ in $dir_variable
#+begin_src bash
shopt -s direxpand
#+end_src

If set, Bash attempts spelling correction on directory names during word completion if the directory name initially supplied does not exist.
#+begin_src bash
shopt -s dirspell
#+end_src

If set, Bash includes filenames beginning with a ‘.’ in the results of filename expansion.
#+begin_src bash
shopt -s dotglob
#+end_src

If set, aliases are expanded as described below under Aliases, Aliases.
#+begin_src bash
# shopt -s expand_aliases
#+end_src

If set, the extended pattern matching features (see [[https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html#Pattern-Matching][Pattern Matching]]) are enabled.
#+begin_src bash
# shopt -s extglob
#+end_src

If set, patterns which fail to match filenames during filename expansion result in an expansion error.
#+begin_src bash
# shopt -s failglob
#+end_src

If set, the pattern ‘**’ used in a filename expansion context will match all files and zero or more directories and subdirectories.
If the pattern is followed by a ‘/’, only directories and subdirectories match.
#+begin_src bash
# shopt -s globstar
#+end_src
Not using this as it's too slow! - Use [[id:2870e3ab-aa92-4006-9899-372135ae00c4][home-brewed @]] instead

If set, shell error messages are written in the standard GNU error message format.
#+begin_src bash
# shopt -s gnu_errfmt
#+end_src

If set, the history list is appended to the file named by the value of the HISTFILE variable when the shell exits, rather than overwriting the file.
#+begin_src bash
shopt -s histappend
#+end_src

If set, and Readline is being used, a user is given the opportunity to re-edit a failed history substitution.
#+begin_src bash
shopt -s histreedit
#+end_src

If set, and Readline is being used, the results of history substitution are not immediately passed to the shell parser.
Instead, the resulting line is loaded into the Readline editing buffer, allowing further modification.
eg. commands using (!, !!, etc.) will print to shell first for confirmation and not auto-execute
#+begin_src bash
shopt -s histverify
#+end_src

If set, Bash will send SIGHUP to all jobs when an interactive login shell exits (see [[https://www.gnu.org/software/bash/manual/html_node/Signals.html][Signals]]).
#+begin_src bash
shopt -s huponexit
#+end_src

If set, and job control is not active, the shell runs the last command of a pipeline not executed in the background
#+begin_src bash
shopt -s lastpipe
#+end_src

If enabled, and the cmdhist option is enabled, multi-line commands are saved to the history with embedded newlines rather than using semicolon separators where possible.
#+begin_src bash
shopt -s lithist
#+end_src

If set, and a file that Bash is checking for mail has been accessed since the last time it was checked, the message "The mail in mailfile has been read" is displayed.
#+begin_src bash
shopt -s mailwarn
#+end_src

If set, and Readline is being used, Bash will not attempt to search the PATH for possible completions when completion is attempted on an empty line.
#+begin_src bash
# shopt -s no_empty_cmd_completion
#+end_src

If set, Bash matches filenames in a case-insensitive fashion when performing filename expansion.
#+begin_src bash
# shopt -s nocaseglob
#+end_src

If set, Bash matches patterns in a case-insensitive fashion when performing matching while executing case or =[[= conditional commands,
when performing pattern substitution word expansions, or when filtering possible completions as part of programmable completion.
#+begin_src bash
# shopt -s nocasematch
#+end_src

If set, Bash allows filename patterns which match no files to expand to a null string, rather than themselves.
#+begin_src bash
# shopt -s nullglob
#+end_src

If this is set, the shift builtin prints an error message when the shift count exceeds the number of parameters.
#+begin_src bash
shopt -s shift_verbose
#+end_src

#+begin_src bash
set -o noclobber
#set -o vi
set bell-style none
# Otherwise some completions will fail
set +o nounset
#+end_src

** ENVIRONMENT variables
*** history
NOTE: exporting a variable makes it available for child processes via the environment

Increase size of history in the terminal. Default is a measly 512 lines
#+begin_src bash
export HISTSIZE=65535
export HISTFILESIZE=65535
#+end_src

Add timestamps to history
#+begin_src bash
export HISTTIMEFORMAT="%F %T  "
#+end_src

Ignore duplicates and trivial one/two char commands as I've a bad habit of doing =cl= all the time.
Furthermore, I can add all the commands I want to ignore to it as well.
#+begin_src bash
export HISTIGNORE='?:??:history*:sosc:que*:ll*'
#+end_src

=ignoredups= allows me to ignore the same command type multiple times consecutively
=ignorespace= does not add commands that start with a space to the history just in case I don't want to log something
=ignoreboth= does both
#+begin_src bash
export HISTCONTROL=ignoreboth
#+end_src

Keeps history forever. Requires ~PROMPT_COMMAND='history -a; history -r'~
#+begin_src bash :tangle no
HISTFILE="${XDG_DATA_HOME:-$HOME/.local/share}/bash_history/$(date +%Y/%m/%d)_${HOSTNAME%%.*}_${USER}_$$"
[[ -d $(dirname ${HISTFILE}) ]] || mkdir -p $(dirname ${HISTFILE})
#+end_src
However, a downside of this is that when sessions span multiple days, commands end up getting logged in the wrong files
Thus, I've moved this to =PROMPT_COMMAND= instead to keep the HISTFILE current.

*** misc

#+begin_src bash
export EDITOR=vim
export VISUAL=gvim
#+end_src

Make less more friendly for non-text input files, see lesspipe(1)
#+begin_src bash
export MANPAGER=less
export PAGER=less
[[ -x /usr/bin/lesspipe ]] && eval "$(SHELL=/bin/sh lesspipe)"
#+end_src

#+begin_src bash
export HOSTNAME="$(hostname)"
export LANG=en_US.UTF-8
#+end_src

** colors
*** ls colors
See [[id:2823d31a-572c-44ec-80e1-84acbbb6412e][dircolors]]
#+begin_src bash
if [[ -x /usr/bin/dircolors ]]; then
    _dircolors=${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/bash/dircolors
    [[ -r $_dircolors ]] && eval "$(/usr/bin/dircolors -b $_dircolors)" || eval "$(/usr/bin/dircolors -b)"
fi
#+end_src

*** base16 themes
#+begin_src bash
export BASE16_SHELL=${XDG_CONFIG_HOME:-$HOME/.config}/base16-shell
[[ -n "$PS1" ]] && [[ -s $BASE16_SHELL/profile_helper.sh ]] && eval "$($BASE16_SHELL/profile_helper.sh)"
if [[ -f ~/.base16_theme ]]; then
  . ~/.base16_theme
else
  base16_solarized-light &> /dev/null
fi
#+end_src

*** colored man pages with less
#+begin_src bash
man() {
    env \
        LESS_TERMCAP_mb=$(printf "\e[1;31m") \
        LESS_TERMCAP_md=$(printf "\e[1;31m") \
        LESS_TERMCAP_me=$(printf "\e[0m") \
        LESS_TERMCAP_se=$(printf "\e[0m") \
        LESS_TERMCAP_so=$(printf "\e[0;43;30m") \
        LESS_TERMCAP_ue=$(printf "\e[0m") \
        LESS_TERMCAP_us=$(printf "\e[1;32m") \
        man "$@"
}
#+end_src

** utilities
*** @: a simpler and faster alternative to globstar
:LOGBOOK:
- Refiled on [2021-03-08 Mon 06:33]
:END:
=@ ls /some/long/path/**/that/I/dont/want/to/type= is converted to =ls $(find /some/long/path/ -path '*/that/I/dont/want/to/type')=

#+begin_src bash
unset -f @
function @ {
    # Description:
    # @ ls /some/long/path/**/that/I/dont/want/to/type is converted to
    #   ls $(find /some/long/path/ -path '*/that/I/dont/want/to/type')

    local _cmd=()
    for i in "$@"; do
        if [[ $i =~ '**' ]]; then
            _cmd+=('$(find'    $(command awk 'BEGIN {FS="**"} {print $1}' <<< "$i"))
            _cmd+=('-path' "'*"$(command awk 'BEGIN {FS="**"} {print $2}' <<< "$i")"')")
        else
            _cmd+=("$i")
        fi
    done
    # echo "${_cmd[@]}"
    # echo
    eval "${_cmd[@]}"
}
#+end_src

*** alert
:LOGBOOK:
- Refiled on [2021-03-08 Mon 06:33]
:END:
Simply function to "alert" when a command completes.
NOTE: This must be used as a function to have access to the history via the fc command

Use like this: =sleep 10 && alert=
#+begin_src bash
unset -f alert
alert() {
    # Pick up display message if provided as argument. If not show the last command that was run
    local _msg=${1:-"'$(fc -nl -1 | sed -e 's/^\s*//' -e 's/\s*[;&|]\+\s*alert$//')' has completed"}

    # Add TMUX information if available
    if [[ -n $TMUX ]]; then
        _msg="$(tmux display-message -p "[#S:#I.#P]") $_msg"
    else
        _msg="[$$] $_msg"
    fi

    # Indicate normal completion or error
    local _icon=$( (($? == 0)) && echo terminal || echo error)

    notify-send --urgency=low -i $_icon "$_msg"
}
#+end_src

*** calc
:LOGBOOK:
- Refiled on [2021-03-08 Mon 06:33]
:END:
Simple wrapper around =irb= to make it more natural to use. eg. ~= 4 + 5~
#+begin_src bash
unset -f =
=() {                                                                                                             # {{{1
    local _input="${@:-$(</dev/stdin)}"
    # echo $_input

    # if [[ $_input =~ [:xdigit:]+\[[:digit:]+:[:digit:]+\] ]]; then
    #   _input=${_input#.*[}
    #   echo $_input
    #   return
    # fi
    # = "($_input >> $_lsb) & ($_msb - $_lsb)"

    # If there's no explicit output formatting, try to infer from the input
    if [[ ! $_input =~ to_s ]]; then
        if [[ $_input =~ 0x ]] || [[ $_input =~ [a-fA-F] ]]; then
            local _base=16
        elif [[ $_input =~ 0b ]]; then
            local _base=2
        fi
        _input="($_input).to_s($_base)"
    fi

    local _result=$(echo "$_input" | irb -m --noverbose | command sed 's/"//g')

    # Pretty-print formatted output
    if [[ $_input =~ 'to_s(16)' ]]; then
        _result="0x${_result}"
    elif [[ $_input =~ 'to_s(2)' ]]; then
        _result="0b${_result}"
    fi

    echo $_result
}
#+end_src

Simple base-converter
#+begin_src bash
unset -f =base
=base() (                                                                                                         # {{{1
    _help () { #{{{
        echo 'SYNTAX:'
        echo '  =base NUM TO [FROM=10]'
        echo '  echo NUM | =base TO [FROM=10]'
        echo '  =base TO [FROM=10] <<< "NUM"'
    } # }}}

    if (( $# <= 1 )); then
        echo -e "ERROR: Insufficient arguments. At least two required\n"; _help
        return 1
    fi

    if [[ -p /dev/stdin ]] || [[ -s /dev/stdin ]]; then
        # From pipe or from redirection respectively
        local _num=$(</dev/stdin)
    else
        local _num=$1
        shift
    fi

    local _obase=$1
    local _ibase=${2:-10}

    case $_ibase in
        2)  _num=${_num#0[bB]} ;;
        16) _num=$(tr '[a-f]' '[A-F]' <<< "${_num#0[xX]}") ;;
    esac

    local _result=$(echo "obase=$_obase; ibase=$_ibase; $_num" | bc)
    case $_obase in
        2)  _result="0b${_result}" ;;
        16) _result="0x${_result}" ;;
    esac

    echo $_result
)

=bin() { =base $1  2 ${2:-10}; }  # Convert to binary, by default from decimal
=dec() { =base $1 10 ${2:-16}; }  # Convert to decimal, by default from hexadecimal
=hex() { =base $1 16 ${2:-10}; }  # Convert to hexadecimal, by default from decimal
#+end_src

#+begin_src bash
unset -f =slice
=slice() (
    _help() {
        echo 'SYNTAX:'
        echo '  =slice NUM MSB LSB'
        echo '  =slice NUM BIT'
        echo '  echo NUM | =slice MSB LSB'
        echo '  =slice MSB LSB <<< "NUM"'
        echo
        echo "NOTE: MSB >= LSB"
    }

    if (( $# >= 3 )); then
        local _num=$1
        shift
    elif [[ -p /dev/stdin ]] || [[ -s /dev/stdin ]]; then
        # From pipe or from redirection respectively
        local _num=$(</dev/stdin)
    elif (( $# < 1 )); then
        echo -e "ERROR: Insufficient arguments. At least one more required\n"; _help
        return 1
    else
        local _num=$1
        shift
    fi

    local _msb=$1
    local _lsb=${2:-$_msb}

    if (( $_lsb > $_msb )); then
        echo -e "ERROR: MSB must be greater than or equal to LSB when slicing\n"; _help
        return 1
    fi

    # echo "in=$_num, msb=$_msb, lsb=$_lsb"
    = "($_num >> $_lsb) & ((1 << ($_msb - $_lsb + 1)) - 1)"
)
#+end_src

*** dir related
:LOGBOOK:
- Refiled on [2021-03-08 Mon 06:33]
:END:
#+begin_src bash
alias md='mkdir -p'

# Create new dir(s) and enter it (last directory if multiple arguments are given)
unset -f mcd
mcd() {
    command mkdir -p "$@" || return
    cd -- "${@: -1}"
}
#+end_src

NOTE: The use of $* is deliberate here as it produces all the scripts arguments separated by the first character of $IFS which, by default, is a space. This allows me to match all arguments against a regex in one go instead of looping over them
#+begin_src bash
dirs() {
    if (( $# == 0 )); then
        builtin dirs -v
    elif [[ "$*" =~ [-+][0-9]+ ]]; then
        # Use long-listing format. Without this, the home directory is display as '~' preventing me from doing something
        # like `cp $(dirs +1)` as it results in an error: pushd: ~/.vim: No such file or directory
        builtin dirs "$@" -l
    else
        builtin dirs "$@"
    fi
}
#+end_src

Silent pushd and uniquifies while pushing
#+begin_src bash
pushd() {
    builtin pushd "$@" > /dev/null;

    # Remove any duplicate entries. The 1st entry will be the PWD so skip it
    local _dir_pos=$(dirs -l -v | tail -n+2 | grep "$PWD$" | sed 's/^\s*//' | cut -d ' ' -f1 | paste -s)
    command popd -n +$_dir_pos &> /dev/null
}
#+end_src

Better dirstack. Adds the following to the usual =cd= behavior:
- =cd ==           Lists the contents of the stack and use fzf to select from it
- =cd=             (with no args) Goes to $REPO_PATH if it's set. If not, or if already on $REPO_PATH, goes to $HOME
- =cd ... [TARG]=  Jump to a directory in the path that starts with TARG.
                 If TARG is not given, show all directories in the filepath and use fzf to select

Note that =pushd= calls =cd= under the hood. So =cdable_vars= and =cdspell= apply to =pushd= as well
#+begin_src bash
cd() {
    if (( "$#" == 0 )); then
        if vcs::is_in_repo > /dev/null; then
            local _dir="$(vcs::get_root)"
            if [[ "$PWD" != "$_dir" ]]; then
                cd "$_dir"
                return
            fi
        fi
        cd "$HOME"
        return
    fi

    case "$1" in
        -)
            pushd
            return
            ;;

        =)
            if hash fzf 2> /dev/null; then
                $(FZF_ALT_C_COMMAND='command dirs -l -p' __fzf_cd__)
            else
                dirs
            fi
            return
            ;;

        ...)
            if hash fzf 2> /dev/null; then
                $(FZF_ALT_C_COMMAND='_dir=$PWD; while [[ -n "$_dir" ]]; do _dir="${_dir%/[^/]*}"; echo ${_dir:-/}; done' \
                    FZF_ALT_C_OPTS="${FZF_ALT_C_OPTS} --select-1 ${2+ --query=$2}" __fzf_cd__)
            fi
            return
            ;;

        ,*\*\**)
            # Split $1 about the first ** into '_path' and '_pattern'.
            local _path=${1%%\*\**}; _path=${_path:-.}
            local _pattern="*$(tr -s '*' <<< ${1#*\*\*})*"

            if hash fzf 2> /dev/null; then
                # Find '_path' for all dirs that match the glob expr '_pattern' and select with FZF from the results
                $(FZF_ALT_C_COMMAND="find ${_path} -type d -path '*${_pattern}*'" __fzf_cd__)
                return
            else
                _dir=$(find $_path -type d -path "*${_pattern}*" -print -quit)
                if [[ -n $_dir ]]; then
                    pushd "$_dir"
                fi
            fi
            ;;
    esac

    pushd "$@"
}

alias ..='cd ..'
#+end_src

*** [[https://github.com/junegunn/fzf][fzf]]
:LOGBOOK:
- Refiled on [2021-03-08 Mon 06:33]
:END:

#+begin_src bash
if [[ -d /opt/fzf ]]; then
    export FZF_PATH=/opt/fzf
elif [[ -d $HOME/.local/install/fzf ]]; then
    export FZF_PATH="$HOME/.local/install/fzf"
else
    echo "$(tput setaf 1)ERROR$(tput sgr0): FZF_PATH is not set"
fi

if [[ -n "$FZF_PATH" ]]; then
    [[ ! "$PATH" == *$FZF_PATH/bin* ]] && export PATH="$PATH:$FZF_PATH/bin"

    # Key bindings
    # Note the order is important because some functions get overridden
    source $FZF_PATH/shell/key-bindings.bash
    source ${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/fzf/fzf_vcs.bash
    source ${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/fzf/key-bindings.bash

    # Customisations
    if hash fd 2> /dev/null; then
        export FZF_DEFAULT_COMMAND="fd --color=never --hidden --exclude .git --type f"
        export FZF_ALT_C_COMMAND="fd --color=never --hidden --exclude .git --type d"
        export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
    fi

    # Clear out old env vars
    export FZF_DEFAULT_OPTS="--ansi --select-1 --exit-0 --inline-info --reverse --tiebreak=length,end --bind=shift-tab:toggle-all,ctrl-n:down,ctrl-p:up"
    unset FZF_ALT_C_OPTS
    unset FZF_CTRL_T_OPTS
    # export FZF_CTRL_T_OPTS='--expect=alt-v,alt-e,alt-c'

    # base16 fzf colorscheme is applied by appending to the FZF_DEFAULT_OPTS env var
    # Thus, I "set" it first before sourcing the base16 file which appends to it
    export BASE16_FZF=${XDG_CONFIG_HOME:-$HOME/.config}/base16-fzf
    [[ -n "$BASE16_THEME" ]] && source "$BASE16_FZF/bash/base16-${BASE16_THEME}.config"
fi
#+end_src

Completion has to be specified at the end: [[*fzf][fzf]]

*** query
:LOGBOOK:
- Refiled on [2020-12-15 Tue 06:18]
:END:
=which= on steroids. Shows aliases and function definitions recursively.
Since this function deals with aliases, it cannot be made into a stand-alone script since aliases are not accessible inside subshells.
#+begin_src bash
query() (
# Yep, parentheses is correct. It makes this a subshell function allowing the definition to be inaccessible from outside
# Thus, no more polluting of shell space with helper functions

__help() {                                                                                                  # {{{1
  echo "Usage:"
  echo "    query [OPTION]... INPUT..."
  echo
  echo "INPUT can be one or more alias, file, command, function etc. but must be specified last"
  echo
  echo "Options:"
  echo "    -h, --help             Print this help"
  echo "        --ascii            Use ASCII instead of extended characters"
  echo "        --color            Colorize output"
  echo "        --nocolor          Don't colorize output"
  echo "    -d, --max-depth <N>    Recurse only N-levels deep. If N=0, query only the specified input"
  echo "        --nodefine         Don't print the function definition"
}


__parse_args() {                                                                                            # {{{1
  #echo "DEBUG: Parse:'$@'"

  # Default values of options
  _opts[ascii]=0
  _opts[color]=1
  _opts[define]=1
  _opts[depth]=-1
  _opts[input]=""
  _opts[level]=0

  local _i
  for _i in "$@"; do
    if [[ $_i =~ ^-h$ ]] || [[ $_i =~ ^--help$ ]]; then
      __help
      return 0
    fi
  done

  local _opt_end=false
  while (( $# > 0 )); do
    #echo "DEBUG: Arg:'$1'"
    case $1 in
      --?*)
        ;&
      -[[:alpha:]])
        if ! $_opt_end && [[ ! $1 =~ ^-l$ ]] && [[ ! $1 =~ ^--level$ ]]; then
          _cmd_recurse+=("$1")
        fi
        ;;&

      --ascii)
        _opts[ascii]=1
        ;;

      --color)
        _opts[color]=1
        ;;
      --nocolor)
        _opts[color]=0
        ;;

      --level|-l)
        # Internal use only. Should not be specified by the user
        shift
        if [[ ! $1 =~ ^[0-9]+$ ]]; then
          echo "ERROR: Current level must be a number"
          return 1;
        fi
        _opts[level]=$1
        ;;

      --max-depth|-d)
        shift
        if [[ ! $1 =~ ^[0-9]+$ ]]; then
          echo -e "ERROR: Max-depth must be a number\n"
          __help
          return 1;
        fi
        _opts[depth]=$1
        ;;

      --nodefine)
        #echo "Don't print function definition"
        _opts[define]=0
        ;;

      --)
        # Standard shell separator between options and arguments
        if ! $_opt_end; then
          _opt_end=true
        fi
        ;;

      -*)
        if ! $_opt_end; then
          echo -e "ERROR: Invalid option: '$1'"
          __help
          return 1;
        fi
        ;&

      ,*)
        # To support multiple inputs
        while (( $# > 1 )); do
          query ${_cmd_recurse[@]} --level 0 $1
          shift
          echo -e "\n"
        done
        _opts[input]=$1
        ;;
    esac
    shift
  done

  # If you don't give me something to work with, then what am I supposed to do?
  if [[ -z ${_opts[input]} ]]; then
    echo "ERROR: No input specified"
    return 1;
  fi
}


__query_alias() {                                                                                                 # {{{1
  echo "${_query_pp[sep]}${_query_pp[input]} (${_query_pp[type]})"
  while read; do
    echo "${_query_pp[spc]}${REPLY}";
  done < <(command type -a -- "${_opts[input]}" | command head -n2)

  # Recurse
  if (( ${_opts[depth]} == -1 )) || (( ${_query_opts[level]} < ${_query_opts[depth]} )); then
    local _out_arr=()
    read -a _out_arr <<< $(command type -a -- ${_opts[input]} | command grep -Po "(?<=aliased to .).*(?='$)")
    local _query_next=()
    local _level_next=$((${_opts[level]} + 1))
    _query_tree[$_level_next]=0

    local _i=0
    for _i in ${_out_arr[@]}; do
      if [[ "$_i" != "${_opts[input]}" ]]; then
        if [[ $(command type -t -- "$_i") =~ file|function|alias ]]; then
          _query_tree[$_level_next]=$(( ${_query_tree[$_level_next]} + 1 ))
          _query_next+=("$_i")
        fi
      fi
    done
    for _i in ${_query_next[@]}; do
      _query_tree[$_level_next]=$(( ${_query_tree[$_level_next]} - 1 ))
      query "${_cmd_recurse[@]}" --level $_level_next $_i
    done
  fi
}


__query_file() {                                                                                                  # {{{1
  echo "${_query_pp[sep]}${_query_pp[input]} (${_query_pp[type]})"
  while read; do
    echo "${_query_pp[spc]}${REPLY}";
  done < <(command type -a -- "${_opts[input]}" | command head -n1)
}


__query_function() {                                                                                              # {{{1
  echo "${_query_pp[sep]}${_query_pp[input]} (${_query_pp[type]})"
  shopt -s extdebug
  IFS=" " read -a _arr <<< $(command declare -F -- "${_opts[input]}")
  shopt -u extdebug
  echo -e "${_query_pp[spc]}Defined in ${_arr[2]} at line ${_arr[1]}"

  # Print the function definition
  if [[ "${_opts[define]}" == "1" ]]; then
    while read; do
      echo "${_query_pp[spc]}${REPLY}";
    done < <(command type -a -- "${_opts[input]}" | command tail -n+2)
  fi
}


__query_pp() {                                                                                                    # {{{1

  _query_pp[spc]=""
  _query_pp[sep]=""

  # Setup the tree-drawing characters
  if [[ "${_opts[ascii]}" == "1" ]]; then
    local _v_bar='|'
    local _h_bar='-'
    local _x_bar='+'
    local _xl_bar='\'
  else
    local _v_bar='│'
    local _h_bar='─'
    local _x_bar='├'
    local _xl_bar='└'
  fi
  _query_pp[xl]=${_query_pp[xl]:-$_x_bar}

  # Colorize the output?
  if [[ "${_opts[color]}" == "1" ]]; then
    local _c_type="$(tput setaf 4)"
    local _c_input="$(tput bold)$(tput setaf 2)"
    local _c_reset="$(tput sgr0)"
  else
    local _c_type=""
    local _c_input=""
    local _c_reset=""
  fi

  if [[ "${_opts[level]}" != "0" ]]; then
    local _i=0
    for (( _i=1; _i <= ${_opts[level]}; _i++ )); do
      #echo ${_query_tree[$_i]}
      if (( ${_query_tree[$_i]} > 0 )); then
        _query_pp[spc]="${_query_pp[spc]}${_v_bar}   "
      else
        _query_pp[spc]="${_query_pp[spc]}    "
      fi
    done
    if (( ${_query_tree[${_opts[level]}]} == 0 )); then
      _x_bar=$_xl_bar
    fi
    _query_pp[sep]="${_query_pp[spc]%????}${_x_bar}${_h_bar}${_h_bar} "
    echo "${_query_pp[spc]%????}${_v_bar}"
  fi

  _query_pp[type]="${_c_type}${_type}${_c_reset}"
  _query_pp[input]="${_c_input}${_opts[input]}${_c_reset}"
}
# }}}1

  #echo "DEBUG: Cmd='$@'"
  # Default values for options
  local -A _opts=()
  local -a _cmd_recurse=()
  __parse_args "$@"
  local _ret_val=$?
  if [[ "$_ret_val" != "0" ]]; then
    return $_ret_val;
  fi

  local _type=$(command type -t -- "${_opts[input]}")
  #echo "DEBUG: Input='${_opts[input]}', Type='$_type'"

  # Pretty-print the tree structure for recursive lookups
  local -A _query_pp=()
  if (( ${_opts[level]} == 0 )); then
    echo
    local -a _query_tree=()
  fi
  __query_pp

  case $_type in
    "file")
      __query_file
      ;;
    "function")
      __query_function
      ;;
    "alias")
      __query_alias
      ;;
    ,*)
      command type -a -- "${_opts[input]}"
      ;;
  esac
)
#+end_src

#+begin_src bash
  alias que=query
#+end_src

*** vcs
Collection of utilities to deal with all VCS related stuff

#+begin_src bash
vcs::is_in_git_repo() {
    local _cwd=$PWD
    if (( $# > 0 )); then
        command cd $1
    fi

    git rev-parse HEAD &> /dev/null
    local _ret=$?

    if (( $# > 0 )); then
        command cd $_cwd
    fi

    return $_ret
}

vcs::is_in_perforce_repo() {
    local _cwd=$PWD
    if (( $# > 0 )); then
        command cd $1
    fi

    p4 info &> /dev/null
    local _ret=$?

    if (( $# > 0 )); then
        command cd $_cwd
    fi

    return $_ret
}

vcs::is_in_repo() {
    vcs::is_in_git_repo "$@" || vcs::is_in_perforce_repo "$@"
}

vcs::get_type() {
    # Description: Check if specified directory is under a Version-controlled system
    # Arguments: 1 - Variable to return VCS type
    #            2 - Directory to check. If skipped, defaults to PWD

    if vcs::is_in_git_repo "$@"; then
        echo "git"
    elif vcs::is_in_perforce_repo "$@"; then
        echo "p4"
    else
        # No VCS. Return empty string
        echo ""
    fi
}

vcs::get_branch() {
    # Description: If PWD is under a VCS, return the branch. If not, return an empty string
    # Arguments:
    # - $1 (optional): Use that as the VCS type instead of calculating it

    local _vcs_type=${1-$(vcs::get_type)}
    #echo "DEBUG: VCS Type=$_vcs_type (vcs::get_branch)"

    if [[ $_vcs_type == "git" ]]; then
        git symbolic-ref --short HEAD 2> /dev/null
    elif [[ $_vcs_type == "p4" ]] && [[ -n "$REPO_PATH" ]] && [[ -f "$REPO_PATH/configuration_id" ]]; then
        echo "$(sed 's/@.*//' "$REPO_PATH/configuration_id" 2> /dev/null)"
    else
        echo ""
    fi
}

vcs::get_status() {
    # Description: Get the status of the VCS - works only for git at the moment
    # Arguments:
    # - $1 (optional): Use as the VCS type instead of calculating it
    # - $2 (optional): Use as the VCS branch instead of calculating it

    local _vcs_type=${1-$(vcs::get_type)}
    local _vcs_branch=${2-$(vcs::get_branch $_vcs_type)}

    if [[ "$_vcs_type" == "git" ]]; then
        if $(echo "$(git log origin/$_vcs_branch..HEAD 2> /dev/null)" | grep '^commit' &> /dev/null); then
            echo "staged"
        elif [[ -n $(git status -s --ignore-submodules=dirty  2> /dev/null) ]]; then
            echo "modified"
        else
            echo "committed"
        fi
    fi
}

vcs::get_root() {
    if vcs::is_in_git_repo "$@"; then
        echo "$(git rev-parse --show-toplevel)"
    elif vcs::is_in_perforce_repo "$@"; then
        echo "$REPO_PATH"
    else
        echo ""
    fi
}
#+end_src

** aliases
Provide a default alias here for the most commonly found tools eg. =grep=, =find= etc.
They might be overridden later by other similar tools if available eg. =ag=, =rg=, =fd= etc.

*Aliases v/s Functions*
A big limitation of aliases is that they are only expanded as the first argument, or after another alias with a trailing space on the end of the command.

eg. let's say I have the following aliases set up
#+begin_src bash :tangle no
alias g=grep
alias vq='v -q <(!!)'
#+end_src
Now, if I run =g SOMETHING= followed by =vq= then =vq= doesn't run as expected because ~!!~ expands to 'g SOMETHING'.
However, in the expanded form, 'g' doesn't get replaced with grep because of the afore-mentioned limitation.

To avoid this, I use functions for my most commonly used aliases so that they work everywhere and, aliases only if I'm sure that they won't be used in the middle of a command.

#+begin_src bash
alias ls='ls -FLH --color=always'
alias l=ls
alias la='ls -A'
alias ll='ls -lh'
alias lla='ll -A'
#+end_src

#+begin_src bash
alias c=clear
alias cl="c;l"

#alias echo '\echo -e'
#alias lock='/usr/local/bin/xlock'
alias mv='mv -vi'
alias cp='cp -vi'
alias rm='rm -vi'
alias rd='rm -rvf'
alias ln='ln -svi'
alias df='df -h'
alias pppath='tr ":" "\n" <<< $PATH'
alias clnpath='export PATH=$(tr ":" "\n" <<< $PATH | perl -ne "print unless \$seen{\$_}++" | paste -s -d":")'

alias C=cat
alias P=$PAGER
alias hh='history | tail'
alias x=exit
alias k9='kill -9'
alias j='jobs -l'
alias pls='sudo $(history -p !!)'
duh() { du -h "$@" | sort -rh; }

ec() { emacsclient --alternate-editor="" --no-wait --create-frame --quiet "$@" & }
alias e=ec
alias evan='emacs --with-profile vanilla'
#+end_src

From https://askubuntu.com/a/185746/38952
Using ww twice ensures that the output is not truncated to the width of the terminal
#+begin_src bash
psgrep() { ps wwup $(command pgrep -f "$@"); }
#+end_src

bookmarks for commonly used config files
#+begin_src bash
alias gosc='$VISUAL ~/.bashrc'
alias gost='$VISUAL ~/.dotfiles/tmux/tmux.conf'
alias gosx='$VISUAL ~/.Xresources'
alias sosc='. ~/.bashrc && clnpath'
#+end_src

*** grep
#+begin_src bash
export GREP_COLORS='1;32'
alias grep='grep -sP --color=always'
#+end_src

I use ~g~ as a generic alias for grep and all its replacements. Hence create a generic alias
#+begin_src bash
alias g=grep
alias gi='g -i'
alias gv='g -v'
#+end_src

*** git
#+begin_src bash
  alias ga='git add'
  alias gA='git add -A .'
  alias gh='git help'
  alias gs='git status'
#+end_src

*** perforce
#+begin_src bash
alias pf='p4'
alias pfd='pf diff'
alias pfdg='P4DIFF= pf diff -du | grepdiff --output-matching=hunk'
alias pfe='pf edit'
alias pflog='pf filelog -stl -m 5'
#+end_src

Make opened files prettier by aligning the columns
#+begin_src bash
pfo() {
    pf opened "$@" | command column -s# -o ' #' -t | command column -o ' ' -t | command sed 's/#/   #/'
}

pfrel() {
    if [[ ! -t 0 ]]; then
        pf where $(command sed -e 's/#.*//' < /dev/stdin)
    elif [[ -n "$1" ]]; then
        pf where $(command sed -e 's/#.*//' "$@")
    else
        return
    fi |  awk "{ if (\$3 != \"$REPO_PATH/...\") { print \$3; } }" | sed -e "s:$REPO_PATH/::"
}

pfor() {
    pfo | pfrel
}
#+end_src

Show top N (default=10) changes
#+begin_src bash
pftop() {
    local num=10
    if (( $# > 0 )) && [[ "$1" =~ ^[0-9]+$ ]]; then
        num=$1
        shift
    fi
    pf changes -m $num "$@" $STEM/...
}
#+end_src

*** rm
Delete in background
#+begin_src bash
unset -f rm_rf
rm_rf_silent() {
    # FIXME: Doesn't work if there are spaces in the filename
    for i in "$@"; do
        # Remove trailing slash and move to hidden
        ni=${i/%\//}
        bi=$(basename $ni)
        ni=${ni/%$bi/.$bi}

        #echo $ni.$$
        command mv $i $ni.$$
        command rm -rf $ni.$$ &
    done
}
alias rdj='rm_rf_silent'
#+end_src

*** [[https://github.com/BurntSushi/ripgrep][ripgrep]]
:PROPERTIES:
:header-args+: :tangle (if (executable-find "rg") (concat (getenv "HOME") "/.bashrc") "no")
:END:
These will be tangled only if =rg= exists
#+begin_src bash
export RIPGREP_CONFIG_PATH=${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/ripgreprc
alias g='command rg'
#+end_src

#+begin_src conf :tangle (if (executable-find "rg") "../ripgreprc" "no")
# This is a tangled file. Do not make any changes here. All changes should preferably be made in the original Org file.
# Use =org-babel-tangle-jump-back-to-org= to jump back to it from any code block.
# If any changes are made here, use =org-babel-detangle= to add it back to the original Org mode file.

# Redefine the cpp extension to make it easier to parse and use it with fd. Start by first clearing it
--type-clear
cpp
# Next, instead of simply flattening it out, let's be a little smarter about it
# First define separate types for header and source files
--type-add
chdr:*.h, *.H, *.h.in, *.H.in, *.hpp, *.hpp.in, *.hxx, *.hxx.in, *.hh, *.hh.in
--type-add
csrc:*.C, *.C.in, *.cpp, *.cpp.in, *.cxx, *.cxx.in, *.cc, *.cc.in, *.inl, *.ipp, *.tpp
# Now, define cpp to be a union of the two
--type-add
cpp:include:chdr
--type-add
cpp:include:csrc

--type-add
rdl:*.rdl

--type-add
sbs:*.sbs

--type-add
hdl:include:verilog

--type-add
hdl:*.x

# Because who cares about case!?
--smart-case
#+end_src

*** vim
#+begin_src bash
alias v=vim
alias vi="vim -u NORC -U NORC -N --cmd 'set rtp="'$VIM,$VIMRUNTIME,$VIM/after'"'"
#+end_src

Open results of the last shell command in vim quickfix.
Very useful for searching something using =rg= etc. and iterating through the results in vim
#+begin_src bash
vq() { v -q <(eval "$(fc -nl -1) $@"); }
vqg() { v -q <(g --vimgrep "$@"); }
#+end_src

Opening up vimdiff takes noticeable amount of time. This will run it only if required.
Using -f keeps the window in the foreground and prevents a whole bunch of diffs opening at the same time
#+begin_src bash
gvim_diff() {
    # Check to see if all files are present. If not, return.
    for i in "$@"; do
        [[ ! -f "$i" ]] && return
    done

    # If there are no differences, print that files are identical and return
    command diff -qs "$@" && return

    # Run vimdiff only if there are differences and all files are present
    gvim -df -c 'set nobackup' "$@"
}
alias vd=gvim_diff
#+end_src

*** [[https://github.com/tmux/tmux][tmux]]
#+begin_src bash
source ${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/tmux/tmuxw.bash
alias tmux='tmuxw'
alias tm='tmux'
#+end_src

** prompt
[[https://wiki.archlinux.org/index.php/Bash/Prompt_customization][Prompt Customization on ArchWiki]]:
=PS1= is the primary prompt displayed before each command.
=PS2= is the secondary prompt used in case of a multi-line command
=PROMPT_COMMAND= is evaluated right before PS1 is displayed.

I use this by assigning it to a function which updates PS1 and PS2 allowing me to have a dynamic prompt
#+begin_src bash
PROMPT_COMMAND=__setprompt
#+end_src

Use bash builtin =checkwinsize= option for terminals which fail to properly set the $COLUMNS variable. (bug workaround)
#+begin_src bash
shopt -s checkwinsize
#+end_src

*** Colors and helper functions
These are the color init strings for the basic file types. A color init string consists of one or more of the following numeric codes:
Attribute codes: 00:Normal, 01:Bold, 04:Underline, 05=Blink, 06:Outline, 07:Reverse, 08:Concealed

| Color   | Foreground | Background |
|---------+------------+------------|
| black   |         30 |         40 |
| red     |         31 |         41 |
| green   |         32 |         42 |
| yellow  |         33 |         43 |
| blue    |         34 |         44 |
| magenta |         35 |         45 |
| cyan    |         36 |         46 |
| white   |         37 |         47 |

NOTE: Non-printable sequences should be enclosed in \[ and \] else it'll cause long commands to not wrap correctly
These are some colors and line-graphics that I use in different prompts so I'm putting them in one place.
#+begin_src bash :tangle no :noweb-ref prompt-common
local _reset="\[$(tput sgr0)\]"
local _bold="\[$(tput bold)\]"
local _fg_black="\[$(tput setaf 0)\]"
local _fg_light_black="\[$(tput setaf 8)\]"
local _fg_red="\[$(tput setaf 1)\]"
local _fg_yellow="\[$(tput setaf 3)\]"
local _fg_green="\[$(tput setaf 2)\]"
local _fg_blue="\[$(tput setaf 4)\]"
local _fg_purple="\[$(tput setaf 5)\]"

# Set line graphics
local _dash="─"
local _ulcorner="┌"
# local _ulcorner="╭"
local _llcorner="└"
# local _llcorner="╰"
#+end_src

Contract the following: /proj/ch_func_dev{1:0}/ASPEN_HIGHLANDS -> ~AH{1:0}
Contract more if it's my directory
#+begin_src bash
prompt::get_compact_pwd() {
    local _pwd=$PWD
    if [[ "$_pwd" =~ ^"$HOME" ]]; then
        _pwd=${_pwd/#$HOME/\~};
    fi
    echo $_pwd
}
#+end_src

*** prompt
This is based on [[http://stevelosh.com/blog/2010/02/my-extravagant-zsh-prompt/][SJL's prompt]] and [[http://aperiodic.net/phil/prompt/][Phil's Zsh prmpt]]. This is what it looks like:
#+begin_example
  ┌ kshenoy @ svvgar-nx16 in ~/.vim ───────────────────── 03:57pm Aug 02, Fri
  └ (^_^) ➤
#+end_example

The function has to be called '__setprompt' as that's what =PROMPT_COMMAND= is set to
#+begin_src bash
__setprompt() {
    # Colors and line-graphics that I use commonly
    <<prompt-common>>
#+end_src

This is all the information I need to set my prompt!
#+begin_src bash
# This has to be placed first
local _exit_status="$?"

# We use this instead of $COLUMNS as when a shell is starting, the $COLUMNS variable is not set
local _columns=$(tput cols)

# The info variables
local _pwd=$(prompt::get_compact_pwd)

# Force time to US Mountain Time. I don't want to export TZ as it messes up some other scripts
local _time="$(TZ=US/Mountain date +%I:%M%P) "
local _user="$(whoami) "
local _user_host_sep="@ "
local _pwd_sep="in "
local _host="$(hostname) "
#+end_src

If root user then colour the arrow red.
#+begin_src bash
if (( "$UID" == 0 )); then
    local _fg_user_symbol=$_fg_red
else
    local _fg_user_symbol=${_bold}${_fg_light_black}
fi
#+end_src

VCS specific
#+begin_src bash
local _vcs_type=$(vcs::get_type)
local _vcs_branch=$(vcs::get_branch $_vcs_type)
local _vcs_sep=" on "

if [[ $_vcs_type == "git" ]]; then
    local _user_symbol=" ±"
elif [[ $_vcs_type == "hg" ]]; then
    local _user_symbol=" ☿"
elif [[ $_vcs_type == "p4" ]]; then
    local _vcs_sep=" on "
else
    #local _user_symbol=" ○"
    #local _user_symbol=" ➤"
    local _user_symbol=" $"
    local _vcs_sep=""
fi
#+end_src

Here, I try to decide what all to put on the prompt depending on the width of the screen.
I work backwards by constructing the full prompt and remove stuff if it's longer than the screen width as most of the it won't be.

Start with everything of interest
#+begin_src bash
_info="${_ulcorner} ${_user}${_user_host_sep}${_host}${_pwd_sep}${_pwd}${_vcs_sep}${_vcs_branch} ${_time}"
#+end_src

If info is wider than the screen, drop the time
#+begin_src bash
if (( $_columns < ${#_info} )); then
    _time=""
    _info="${_ulcorner} ${_user}${_user_host_sep}${_host}${_pwd_sep}${_pwd}${_vcs_sep}${_vcs_branch} "
fi
_pwd_sep="${_fg_light_black}${_pwd_sep}${_reset}"
#+end_src

If the info still can't fit, drop user and domain info
#+begin_src bash
if (( $_columns < ${#_info} )); then
    _user=""
    _user_host_sep=""
    _host=""
    _pwd_sep=""
    _info="${_ulcorner} ${_pwd}${_vcs_sep}${_vcs_branch} "
fi
#+end_src

If the info still can't fit, drop vcs branch
#+begin_src bash
if (( $_columns < ${#_info} )); then
    _vcs_sep=""
    _vcs_branch=""
    _info="${_ulcorner} ${_pwd} "
fi
#+end_src

If the info still can't fit, truncate PWD
#+begin_src bash
if (( $_columns < ${#_info} )); then
    _pwd_sep="..."
    while (( $_columns < ${#_info} )); do
        _pwd=`echo $_pwd | sed 's|^/\?[^/]*/||'`
        _info="${_ulcorner} ${_pwd_sep}${_pwd} "
    done
    _pwd_sep="${_bold}${_fg_green}${_pwd_sep}${_reset}"
fi

local _fillsize=$(( $_columns - ${#_info} - 1 ))
local _fill=$(printf "${_dash}%.0s" $(seq 1 $_fillsize))" "
#+end_src

Colorize vcs:
#+begin_src bash
if [[ $_vcs_type == "git" ]]; then
    local _vcs_status=$(vcs::get_status ${_vcs_type} ${_vcs_branch})
    if [[ "${_vcs_status}" == "staged" ]]; then
        _vcs_branch="${_fg_yellow}${_vcs_branch}${_reset}"
    elif [[ "${_vcs_status}" == "modified" ]]; then
        _vcs_branch="${_fg_red}${_vcs_branch}${_reset}"
    elif [[ "${_vcs_status}" == "committed" ]]; then
        _vcs_branch="${_fg_green}${_vcs_branch}${_reset}"
    fi
elif [[ $_vcs_type == "p4" ]]; then
    if (( $(p4 opened 2> /dev/null | wc -l) > 0 )); then
        _vcs_branch="${_fg_red}${_vcs_branch}${_reset}"
    else
        _vcs_branch="${_fg_green}${_vcs_branch}${_reset}"
    fi
fi
#+end_src

Create exit status indicator based on exit status of last command
#+begin_src bash
if (( "$_exit_status" == 0 )); then
    _exit_status="${_bold}${_fg_green} (^_^)"
else
    _exit_status="${_fg_red} (@_@)"
fi
#+end_src

Now that I've decided what all I want to put on the prompt and how, it's time to set the prompt variables
#+begin_src bash
PS1="\n${_reset}"
PS1+="${_fg_light_black}${_ulcorner}${_reset} "
PS1+="${_fg_red}${_user}${_reset}"
PS1+="${_fg_light_black}${_user_host_sep}${_reset}"
PS1+="${_fg_yellow}${_host}${_reset}"
PS1+="${_pwd_sep}"
PS1+="${_fg_blue}${_pwd}${_reset}"
PS1+="${_fg_light_black}${_vcs_sep}${_reset}"
PS1+="${_vcs_branch} "
PS1+="${_fg_light_black}${_fill}${_reset}"
PS1+="${_fg_yellow}${_time}${_reset}"
PS1+="\n"
PS1+="${_fg_light_black}${_llcorner}${_reset}"
PS1+="${_exit_status}${_reset}"
PS1+="${_fg_user_symbol}${_user_symbol}${_reset} "

PS2="      ${_fg_user_symbol}...${_reset}   "
#+end_src

Evaluate dynamic variables only if dyn_vars is defined (Not required for prompt)
#+begin_src bash
declare -F dyn_vars &> /dev/null && dyn_vars
#+end_src

Set HISTFILE here to keep it current when sessions span multiple days
FIXME: Find a better way to do this i.e. do it once a day instead of everytime the prompt is refreshed
#+begin_src bash
HISTFILE="${XDG_DATA_HOME:-$HOME/.local/share}/bash_history/$(date +%Y/%m/%d)_${HOSTNAME%%.*}_${USER}_$$"
[[ -d $(dirname ${HISTFILE}) ]] || mkdir -p $(dirname ${HISTFILE})
#+end_src

Write to the history file immediately instead of waiting till the end of the session
#+begin_src bash
history -a
}
#+end_src

** PATH
#+begin_src bash
if ((which ruby &> /dev/null) && (which gem &> /dev/null)); then
  export PATH="$(ruby -rubygems -e 'puts Gem.user_dir')/bin:$PATH"
fi
export PATH="$HOME/bin:$HOME/.local/bin:$PATH"
clnpath
#+end_src

** local override
Update permissions of the history when exiting as root
#+begin_src bash
__histfile_perm_update__() {
    if [[ -f $HISTFILE ]]; then
        echo "Changing permissions of HISTFILE..."
        chown kshenoy $HISTFILE
        chgrp kshenoy $HISTFILE
        chmod 640 $HISTFILE
    fi
}
trap __histfile_perm_update__ EXIT

## When leaving the console, clear the screen to increase privacy
if [[ "$SHLVL" = 1 ]]; then
    [[ -x /usr/bin/clear_console ]] && /usr/bin/clear_console -q
fi
#+end_src

*** home
To connect to work-vpn
#+begin_src bash :tangle (if (string-match "buntu" (system-name)) (concat (getenv "HOME") "/.bashrc") "no")
alias gp=globalprotect

work_vpn() {
    # if command grep Connected <<< $(globalprotect show --status); then
    if command grep gpd0 <<< $(ifconfig -s) >& /dev/null; then
        echo "VPN is already connected"
    else
        globalprotect connect --portal vpn.amd.com --username kshenoy
    fi
}
#+end_src

#+begin_src bash :tangle (if (string-match "buntu" (system-name)) (concat (getenv "HOME") "/.bashrc") "no")
alias boot2win='sudo grub-reboot Windows && shutdown -r 0'
#+end_src

*** WSL
#+begin_src bash :tangle (if (string-match "windows" (system-name)) (concat (getenv "HOME") "/.bashrc") "no")
export LIBGL_ALWAYS_INDIRECT=1
# Need to specify the IP of the host
export DISPLAY=192.168.1.11:0
#+end_src

**** TODO Move WSL specific bash_profile and bashrc_local_override settings here

*** bashrc_local
And finally, check for a .bashrc_local and load it
#+begin_src bash
[[ -f ~/.bashrc_local_override ]] && . ~/.bashrc_local_override
#+end_src

** completion
Applying dumber completions first so that the smarter ones can come later and can override them

*** command completion
#+begin_src bash
if [[ -f /etc/bash_completion ]] && ! shopt -oq posix; then
    . /etc/bash_completion
fi

complete -A hostname   rsh rcp telnet rlogin r ftp ping disk
complete -A export     printenv
complete -A variable   export local readonly unset
complete -A enabled    builtin
complete -A alias      alias unalias
complete -A function   function
complete -A user       su mail finger

complete -A helptopic  help     # currently same as builtins
complete -A shopt      shopt
complete -A stopped -P '%' bg
complete -A job -P '%' fg jobs disown

complete -A directory  mkdir rmdir
complete -A directory  -o default cd

# Compression
complete -f -o default -X '*.+(zip|ZIP)'  zip
complete -f -o default -X '!*.+(zip|ZIP)' unzip
complete -f -o default -X '*.+(z|Z)'      compress
complete -f -o default -X '!*.+(z|Z)'     uncompress
complete -f -o default -X '*.+(gz|GZ)'    gzip
complete -f -o default -X '!*.+(gz|GZ)'   gunzip
complete -f -o default -X '*.+(bz2|BZ2)'  bzip2
complete -f -o default -X '!*.+(bz2|BZ2)' bunzip2

# Misc filetypes
complete -f -o default -X '!*.ps'  gs ghostview ps2pdf ps2ascii
complete -f -o default -X '!*.dvi' dvips dvipdf xdvi dviselect dvitype
complete -f -o default -X '!*.pdf' acroread pdf2ps
complete -f -o default -X '!*.+(pdf|ps)' gv
complete -f -o default -X '!*.texi*' makeinfo texi2dvi texi2html texi2pdf
complete -f -o default -X '!*.tex' tex latex slitex
complete -f -o default -X '!*.lyx' lyx
complete -f -o default -X '!*.+(htm*|HTM*)' lynx html2ps
complete -f -o default -X '!*.pl'  perl perl5
complete -f -o default -X '!*.gv'   dot
complete -f -o default -X '!*.gif'  kview

# Multimedia
#complete -f -o default -X '!*.+(jp*g|gif|xpm|png|bmp)' xv gimp
#complete -f -o default -X '!*.+(mp3|MP3)' mpg123 mpg321
#complete -f -o default -X '!*.+(ogg|OGG)' ogg123
#+end_src

*** fzf completion
Rest of fzf configuration defined above: [[*\[\[https://github.com/junegunn/fzf\]\[fzf\]\]][fzf]]

#+begin_src bash
[[ $- == *i* ]] && source "$FZF_PATH/shell/completion.bash" 2> /dev/null
#+end_src

*** TODO COMMENT tmux completion
Use tmux/tmux_completion.bash

*** alias completion
Automatically add completion for all aliases to commands having completion functions
This must be called only at the very end

#+begin_src bash
_compl_alias() {
    [[ -z "$1" ]] && return
    local _alias="$1"

    if (( $# >= 2 )); then
        local _cmd="$2"
    else
        local _cmd="$(alias $_alias 2> /dev/null | sed -e 's/^.*=//' -e 's/ .*$//' | tr -d "'")"
    fi
    [[ -z "$_cmd" ]] && return

    eval "$(complete -p $_cmd | sed "s/$_cmd$/$_alias/")"
}
#+end_src

Note the order of application is important
#+begin_src bash
_compl_alias e    emacs
_compl_alias g    grep
_compl_alias v    vim
_compl_alias vd   diff
_compl_alias vile less
for _alias in C P gi gv l la ll lla doomacs; do
    _compl_alias "$_alias"
done
#+end_src

* COMMENT inputrc
The use of ~set keymap~ below doesn't look right. =/etc/inputrc= seems to be using ~$if mode~ instead

#+begin_src bash
## Readline settings

# prepends a symbol to PS1 to indicate whether we're in emacs/vi mode
# set show-mode-in-prompt-on

# Handle Meta (Alt) correctly
set meta-flag on
set convert-meta off
set output-meta on

# Rebind C-A-H to ignore hyphens and underscores while deleting a filename
#$if mode=emacs
#"\eC-h": unix-filename-rubout
#$endif

# Don't beep!
set bell-style none

# Case-insensitive filename matching and completion
set completion-ignore-case on

set keymap emacs
# Switch to vi mode
"\C-x\C-t": vi-editing-mode

# Switch to emacs mode
set keymap vi-command
"\C-x\C-t": emacs-editing-mode
set keymap vi-insert
"\C-x\C-t": emacs-editing-mode

# Open up $VISUAL to edit command
set keymap vi-command
"\C-x\C-e": edit-and-execute-command
set keymap vi-insert
"\C-x\C-e": edit-and-execute-command


# Set default editing mode
set editing-mode emacs
#+end_src

* LS_COLORS/dircolors
:PROPERTIES:
:header-args+: :tangle generated/dircolors
:END:

#+begin_src bash :export none
# This is a tangled file. Do not make any changes here. All changes should preferably be made in the original Org file.
# Use =org-babel-tangle-jump-back-to-org= to jump back to it from any code block.
# If any changes are made here, use =org-babel-detangle= to add it back to the original Org mode file.
#+end_src

=ls= uses the value of the environment variable =LS_COLORS= to display. =dircolors= is a utility to set =LS_COLORS=

=COLOR= needs one of these arguments:
- ~tty~ colorizes output to ttys, but not pipes.
- ~all~ adds color characters to all output
- ~none~ shuts colorization off.
#+begin_src bash
COLOR tty
#+end_src

Extra command line options for ls go here. Basically these ones are:
~-F~ show '/' for dirs, '*' for executables, etc.
~-T 0~ don't trust tab spacing when formatting ls output.
#+begin_src bash :tangle no
OPTIONS -F -T 0
#+end_src

There should be one TERM entry for each termtype that is colorizable
#+begin_src bash
TERM Eterm
TERM ansi
TERM color_xterm
TERM con132x25
TERM con132x30
TERM con132x43
TERM con132x60
TERM con80x25
TERM con80x28
TERM con80x30
TERM con80x43
TERM con80x50
TERM con80x60
TERM console
TERM dtterm
TERM gnome
TERM kon
TERM konsole
TERM kterm
TERM linux
TERM linux-c
TERM mach-color
TERM rxvt
TERM screen
TERM screen
TERM screen-w
TERM screen.linux
TERM uxterm
TERM vt100
TERM xterm
TERM xterm-256color
TERM xterm-debian
#+end_src

These are the color init strings for the basic file types. A color init string consists of one or more of the following numeric codes:
Attribute codes: 00:Normal, 01:Bold, 04:Underline, 05=Blink, 06:Outline, 07:Reverse, 08:Concealed
| Color   | Foreground | Background |
|-----------------------------------|
| black   |     30     |     40     |
| red     |     31     |     41     |
| green   |     32     |     42     |
| yellow  |     33     |     43     |
| blue    |     34     |     44     |
| magenta |     35     |     45     |
| cyan    |     36     |     46     |
| white   |     37     |     47     |

#+begin_src bash
BLK     40;33;01    # block device driver
CHR     40;33;01    # character device driver
DIR     00;34       # directory
DOOR    01;35       # door
EXEC    00;32       # files with execute permissions
FIFO    40;33       # pipe
FILE    00          # normal file
LINK    00;36       # symbolic link. (If this is set to 'target' instead of a numerical value, the color is as for the file pointed to.)
MISSING 05;37;41    # ... and the files they point to
NORMAL  00          # global default, although everything should be something.
ORPHAN  01;37;41    # orphaned syminks
SOCK    01;35       # socket
#+end_src

List any file extensions like '.gz' or '.tar' that you would like ls to colorize below. Put the extension, a space, and the color init string.
(and any comments you want to add after a '#')

Executables
#+begin_src bash
.cmd 00;32
.exe 00;32
.com 00;32
.btm 00;32
.bat 00;32
.sh  00;32
.csh 00;32
#+end_src

Archives or compressed files
#+begin_src bash
.tar  00;31
.tgz  00;31
.arj  00;31
.taz  00;31
.lzh  00;31
.zip  00;31
.z    00;31
.Z    00;31
.gz   00;31
.bz2  00;31
.deb  00;31
.rpm  00;31
.jar  00;31
.bz   00;31
.tz   00;31
.cpio 00;31
#+end_src

Image formats
#+begin_src bash
.jpg  00;35
.jpeg 00;35
.gif  00;35
.bmp  00;35
.pbm  00;35
.pgm  00;35
.ppm  00;35
.tga  00;35
.xbm  00;35
.xpm  00;35
.tif  00;35
.tiff 00;35
.png  00;35
.mpg  00;35
.mpeg 00;35
.avi  00;35
.fli  00;35
.gl   00;35
.dl   00;35
.xcf  00;35
.xwd  00;35
#+end_src

Audio formats
#+begin_src bash
.ogg 00;35
.mp3 00;35
.wav 00;35
#+end_src

Documents
#+begin_src bash :tangle no
.csv 00;00
.xls 00;00
.pdf 00;00
.doc 00;00
.txt 00;00
.md  00;00
.ppt 00;00
#+end_src

* Local variables
:PROPERTIES:
:header-args+: :export none :tangle no
:END:
Use =add-file-local-variable= or =add-file-local-variable-prop-line= instead of adding these manually

[[https://www.reddit.com/r/emacs/comments/372nxd/how_to_move_init_to_orgbabel/crjicdv/][Auto-tangle on save]] - Not using it because it was too aggressive for at least this file considering how often I tinker with it
# eval: (add-hook 'after-save-hook (lambda ()(org-babel-tangle)) nil t)

# Local Variables:
# End:
