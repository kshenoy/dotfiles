# bashrc
# :PROPERTIES:
# :header-args+: :tangle (concat (getenv "HOME") "/.bashrc")
# :END:

# [[file:~/.config/dotfiles/bash/bashrc.org::*bashrc][bashrc:1]]
# This is a tangled file. Do not make any changes here. All changes should preferably be made in the original Org file.
# Use =org-babel-tangle-jump-to-org= to jump back to it from any code block.
# If any changes are made here, use =org-babel-detangle= to add it back to the original Org mode file.
# bashrc:1 ends here



# Proceed only if its an interactive shell

# [[file:~/.config/dotfiles/bash/bashrc.org::*bashrc][bashrc:3]]
[[ $- == *i* ]] || return
# bashrc:3 ends here

# local init
# Any local settings that need to be set initially go here

# [[file:~/.config/dotfiles/bash/bashrc.org::*local%20init][local init:1]]
[[ -f ~/.bashrc_local_init ]] && . ~/.bashrc_local_init
# local init:1 ends here

# interactive, login shell settings
# Turn off TTY "start" and "stop" commands in all interactive shells.
# They default to ~C-q~ and ~C-s~. I want to use ~C-s~ to do forward history search.

# [[file:~/.config/dotfiles/bash/bashrc.org::*interactive,%20login%20shell%20settings][interactive, login shell settings:1]]
stty start ''
stty stop  ''
stty -ixon # disable XON/XOFF flow control
stty ixoff # enable sending (to app) of start/stop characters
stty ixany # let any character restart output, not only start character
# interactive, login shell settings:1 ends here

# configuration
# default permissions

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:1]]
umask 002
# configuration:1 ends here



# [[https://unix.stackexchange.com/questions/32409/set-and-shopt-why-two][shopt v/s set]]

# Using [[https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html][shopt]]:
# ~-s~ : set
# ~-u~ : unset
# ~-q~ : query whether set/unset

# [[http://wiki.bash-hackers.org/internals/shell_options][List of shell options]]

# If set, a command name that is the name of a directory is executed as if it were the argument to the cd command.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:2]]
shopt -u autocd
# configuration:2 ends here



# If this is set, an argument to the cd builtin command that is not a directory is assumed to be the name of a variable whose value is the directory to change to.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:3]]
shopt -s cdable_vars
# configuration:3 ends here



# If set, minor errors in the spelling of a directory component in a cd command will be corrected.
# The errors checked for are transposed characters, a missing character, and a character too many.
# If a correction is found, the corrected path is printed, and the command proceeds.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:4]]
shopt -s cdspell
# configuration:4 ends here



# If this is set, Bash checks that a command found in the hash table exists before trying to execute it.
# If a hashed command no longer exists, a normal path search is performed.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:5]]
shopt -s checkhash
# configuration:5 ends here



# If set, Bash lists the status of any stopped and running jobs before exiting an interactive shell.
# If any jobs are running, this causes the exit to be deferred until a second exit is attempted without an intervening command (see Job Control).
# The shell always postpones exiting if any jobs are stopped.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:6]]
shopt -s checkjobs
# configuration:6 ends here



# If set, Bash checks the window size after each command and, if necessary, updates the values of LINES and COLUMNS.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:7]]
shopt -s checkwinsize
# configuration:7 ends here



# If set, Bash attempts to save all lines of a multiple-line command in the same history entry.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:8]]
shopt -s cmdhist
# configuration:8 ends here



# If set, Bash quotes all shell metacharacters in filenames and directory names when performing completion.
# If not set, Bash removes metacharacters such as the dollar sign from the set of characters that will be quoted in completed filenames when these metacharacters appear in shell variable references in words to be completed.
# This means that dollar signs in variable names that expand to directories will not be quoted; however, any dollar signs appearing in filenames will not be quoted, either.
# This is active only when bash is using backslashes to quote completed filenames.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:9]]
shopt -s complete_fullquote
# configuration:9 ends here



# If set, Bash replaces directory names with the results of word expansion when performing filename completion.
# This changes the contents of the readline editing buffer. If not set, Bash attempts to preserve what the user typed.
# I use it mainly to prevent bash from escaping $ in $dir_variable

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:10]]
shopt -s direxpand
# configuration:10 ends here



# If set, Bash attempts spelling correction on directory names during word completion if the directory name initially supplied does not exist.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:11]]
shopt -s dirspell
# configuration:11 ends here



# If set, Bash includes filenames beginning with a ‘.’ in the results of filename expansion.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:12]]
shopt -s dotglob
# configuration:12 ends here



# If set, aliases are expanded as described below under Aliases, Aliases.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:13]]
# shopt -s expand_aliases
# configuration:13 ends here



# If set, the extended pattern matching features (see [[https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html#Pattern-Matching][Pattern Matching]]) are enabled.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:14]]
# shopt -s extglob
# configuration:14 ends here



# If set, patterns which fail to match filenames during filename expansion result in an expansion error.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:15]]
# shopt -s failglob
# configuration:15 ends here



# If set, the pattern ‘**’ used in a filename expansion context will match all files and zero or more directories and subdirectories.
# If the pattern is followed by a ‘/’, only directories and subdirectories match.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:16]]
# shopt -s globstar
# configuration:16 ends here


# Not using this as it's too slow! - Use [[id:2870e3ab-aa92-4006-9899-372135ae00c4][home-brewed @]] instead

# If set, shell error messages are written in the standard GNU error message format.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:17]]
# shopt -s gnu_errfmt
# configuration:17 ends here



# If set, the history list is appended to the file named by the value of the HISTFILE variable when the shell exits, rather than overwriting the file.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:18]]
shopt -s histappend
# configuration:18 ends here



# If set, and Readline is being used, a user is given the opportunity to re-edit a failed history substitution.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:19]]
shopt -s histreedit
# configuration:19 ends here



# If set, and Readline is being used, the results of history substitution are not immediately passed to the shell parser.
# Instead, the resulting line is loaded into the Readline editing buffer, allowing further modification.
# eg. commands using (!, !!, etc.) will print to shell first for confirmation and not auto-execute

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:20]]
shopt -s histverify
# configuration:20 ends here



# If set, Bash will send SIGHUP to all jobs when an interactive login shell exits (see [[https://www.gnu.org/software/bash/manual/html_node/Signals.html][Signals]]).

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:21]]
shopt -s huponexit
# configuration:21 ends here



# If set, and job control is not active, the shell runs the last command of a pipeline not executed in the background

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:22]]
shopt -s lastpipe
# configuration:22 ends here



# If enabled, and the cmdhist option is enabled, multi-line commands are saved to the history with embedded newlines rather than using semicolon separators where possible.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:23]]
shopt -s lithist
# configuration:23 ends here



# If set, and a file that Bash is checking for mail has been accessed since the last time it was checked, the message "The mail in mailfile has been read" is displayed.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:24]]
shopt -s mailwarn
# configuration:24 ends here



# If set, and Readline is being used, Bash will not attempt to search the PATH for possible completions when completion is attempted on an empty line.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:25]]
# shopt -s no_empty_cmd_completion
# configuration:25 ends here



# If set, Bash matches filenames in a case-insensitive fashion when performing filename expansion.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:26]]
# shopt -s nocaseglob
# configuration:26 ends here



# If set, Bash matches patterns in a case-insensitive fashion when performing matching while executing case or =[[= conditional commands,
# when performing pattern substitution word expansions, or when filtering possible completions as part of programmable completion.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:27]]
# shopt -s nocasematch
# configuration:27 ends here



# If set, Bash allows filename patterns which match no files to expand to a null string, rather than themselves.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:28]]
# shopt -s nullglob
# configuration:28 ends here



# If this is set, the shift builtin prints an error message when the shift count exceeds the number of parameters.

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:29]]
shopt -s shift_verbose
# configuration:29 ends here

# [[file:~/.config/dotfiles/bash/bashrc.org::*configuration][configuration:30]]
set -o noclobber
#set -o vi
set bell-style none
# Otherwise some completions will fail
set +o nounset
# configuration:30 ends here

# history
# NOTE: exporting a variable makes it available for child processes via the environment

# Increase size of history in the terminal. Default is a measly 512 lines

# [[file:~/.config/dotfiles/bash/bashrc.org::*history][history:1]]
export HISTSIZE=65535
export HISTFILESIZE=65535
# history:1 ends here



# Add timestamps to history

# [[file:~/.config/dotfiles/bash/bashrc.org::*history][history:2]]
export HISTTIMEFORMAT="%F %T  "
# history:2 ends here



# Ignore duplicates and trivial one/two char commands as I've a bad habit of doing =cl= all the time.
# Furthermore, I can add all the commands I want to ignore to it as well.

# [[file:~/.config/dotfiles/bash/bashrc.org::*history][history:3]]
export HISTIGNORE='?:??:history*:sosc:que*:ll*'
# history:3 ends here



# =ignoredups= allows me to ignore the same command type multiple times consecutively
# =ignorespace= does not add commands that start with a space to the history just in case I don't want to log something
# =ignoreboth= does both

# [[file:~/.config/dotfiles/bash/bashrc.org::*history][history:4]]
export HISTCONTROL=ignoreboth
# history:4 ends here

# misc


# [[file:~/.config/dotfiles/bash/bashrc.org::*misc][misc:1]]
export EDITOR=vim
export VISUAL=gvim
# misc:1 ends here



# Make less more friendly for non-text input files, see lesspipe(1)

# [[file:~/.config/dotfiles/bash/bashrc.org::*misc][misc:2]]
export MANPAGER=less
export PAGER=less
[[ -x /usr/bin/lesspipe ]] && eval "$(SHELL=/bin/sh lesspipe)"
# misc:2 ends here

# [[file:~/.config/dotfiles/bash/bashrc.org::*misc][misc:3]]
export HOSTNAME="$(hostname)"
export LANG=en_US.UTF-8
# misc:3 ends here

# ls colors
# See [[id:2823d31a-572c-44ec-80e1-84acbbb6412e][dircolors]]

# [[file:~/.config/dotfiles/bash/bashrc.org::*ls%20colors][ls colors:1]]
if [[ -x /usr/bin/dircolors ]]; then
    _dircolors=${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/bash/dircolors
    [[ -r $_dircolors ]] && eval "$(/usr/bin/dircolors -b $_dircolors)" || eval "$(/usr/bin/dircolors -b)"
fi
# ls colors:1 ends here

# base16 themes

# [[file:~/.config/dotfiles/bash/bashrc.org::*base16%20themes][base16 themes:1]]
export BASE16_SHELL=${XDG_CONFIG_HOME:-$HOME/.config}/base16-shell
[[ -n "$PS1" ]] && [[ -s $BASE16_SHELL/profile_helper.sh ]] && eval "$($BASE16_SHELL/profile_helper.sh)"
base16_solarized-light &> /dev/null
# base16 themes:1 ends here

# colored man pages with less

# [[file:~/.config/dotfiles/bash/bashrc.org::*colored%20man%20pages%20with%20less][colored man pages with less:1]]
man() {
    env \
        LESS_TERMCAP_mb=$(printf "\e[1;31m") \
        LESS_TERMCAP_md=$(printf "\e[1;31m") \
        LESS_TERMCAP_me=$(printf "\e[0m") \
        LESS_TERMCAP_se=$(printf "\e[0m") \
        LESS_TERMCAP_so=$(printf "\e[0;43;30m") \
        LESS_TERMCAP_ue=$(printf "\e[0m") \
        LESS_TERMCAP_us=$(printf "\e[1;32m") \
        man "$@"
}
# colored man pages with less:1 ends here

# vcs
# Collection of utilities to deal with all VCS related stuff


# [[file:~/.config/dotfiles/bash/bashrc.org::*vcs][vcs:1]]
vcs::is_in_git_repo() {
    local _cwd=$PWD
    if (( $# > 0 )); then
        command cd $1
    fi

    git rev-parse HEAD &> /dev/null
    local _ret=$?

    if (( $# > 0 )); then
        command cd $_cwd
    fi

    return $_ret
}

vcs::is_in_perforce_repo() {
    local _cwd=$PWD
    if (( $# > 0 )); then
        command cd $1
    fi

    p4 info &> /dev/null
    local _ret=$?

    if (( $# > 0 )); then
        command cd $_cwd
    fi

    return $_ret
}

vcs::is_in_repo() {
    vcs::is_in_git_repo "$@" || vcs::is_in_perforce_repo "$@"
}

vcs::get_type() {
    # Description: Check if specified directory is under a Version-controlled system
    # Arguments: 1 - Variable to return VCS type
    #            2 - Directory to check. If skipped, defaults to PWD

    if vcs::is_in_git_repo "$@"; then
        echo "git"
    elif vcs::is_in_perforce_repo "$@"; then
        echo "p4"
    else
        # No VCS. Return empty string
        echo ""
    fi
}

vcs::get_branch() {
    # Description: If PWD is under a VCS, return the branch. If not, return an empty string
    # Arguments:
    # - $1 (optional): Use that as the VCS type instead of calculating it

    local _vcs_type=${1-$(vcs::get_type)}
    #echo "DEBUG: VCS Type=$_vcs_type (vcs::get_branch)"

    if [[ $_vcs_type == "git" ]]; then
        git symbolic-ref --short HEAD 2> /dev/null
    elif [[ $_vcs_type == "p4" ]] && [[ -n "$REPO_PATH" ]] && [[ -f "$REPO_PATH/configuration_id" ]]; then
        echo "$(sed 's/@.*//' "$REPO_PATH/configuration_id" 2> /dev/null)"
    else
        echo ""
    fi
}

vcs::get_status() {
    # Description: Get the status of the VCS - works only for git at the moment
    # Arguments:
    # - $1 (optional): Use as the VCS type instead of calculating it
    # - $2 (optional): Use as the VCS branch instead of calculating it

    local _vcs_type=${1-$(vcs::get_type)}
    local _vcs_branch=${2-$(vcs::get_branch $_vcs_type)}

    if [[ "$_vcs_type" == "git" ]]; then
        if $(echo "$(git log origin/$_vcs_branch..HEAD 2> /dev/null)" | grep '^commit' &> /dev/null); then
            echo "staged"
        elif [[ -n $(git status -s --ignore-submodules=dirty  2> /dev/null) ]]; then
            echo "modified"
        else
            echo "committed"
        fi
    fi
}

vcs::get_root() {
    if vcs::is_in_git_repo "$@"; then
        echo "$(git rev-parse --show-toplevel)"
    elif vcs::is_in_perforce_repo "$@"; then
        echo "$REPO_PATH"
    else
        echo ""
    fi
}
# vcs:1 ends here

# query
# :LOGBOOK:
# - Refiled on [2020-12-15 Tue 06:18]
# :END:
# =which= on steroids. Shows aliases and function definitions recursively.
# Since this function deals with aliases, it cannot be made into a stand-alone script since aliases are not accessible inside subshells.

# [[file:~/.config/dotfiles/bash/bashrc.org::*query][query:1]]
query() (
# Yep, parentheses is correct. It makes this a subshell function allowing the definition to be inaccessible from outside
# Thus, no more polluting of shell space with helper functions

__help() {                                                                                                  # {{{1
  echo "Usage:"
  echo "    query [OPTION]... INPUT..."
  echo
  echo "INPUT can be one or more alias, file, command, function etc. but must be specified last"
  echo
  echo "Options:"
  echo "    -h, --help             Print this help"
  echo "        --ascii            Use ASCII instead of extended characters"
  echo "        --color            Colorize output"
  echo "        --nocolor          Don't colorize output"
  echo "    -d, --max-depth <N>    Recurse only N-levels deep. If N=0, query only the specified input"
  echo "        --nodefine         Don't print the function definition"
}


__parse_args() {                                                                                            # {{{1
  #echo "DEBUG: Parse:'$@'"

  # Default values of options
  _opts[ascii]=0
  _opts[color]=1
  _opts[define]=1
  _opts[depth]=-1
  _opts[input]=""
  _opts[level]=0

  local _i
  for _i in "$@"; do
    if [[ $_i =~ ^-h$ ]] || [[ $_i =~ ^--help$ ]]; then
      __help
      return 0
    fi
  done

  local _opt_end=false
  while (( $# > 0 )); do
    #echo "DEBUG: Arg:'$1'"
    case $1 in
      --?*)
        ;&
      -[[:alpha:]])
        if ! $_opt_end && [[ ! $1 =~ ^-l$ ]] && [[ ! $1 =~ ^--level$ ]]; then
          _cmd_recurse+=("$1")
        fi
        ;;&

      --ascii)
        _opts[ascii]=1
        ;;

      --color)
        _opts[color]=1
        ;;
      --nocolor)
        _opts[color]=0
        ;;

      --level|-l)
        # Internal use only. Should not be specified by the user
        shift
        if [[ ! $1 =~ ^[0-9]+$ ]]; then
          echo "ERROR: Current level must be a number"
          return 1;
        fi
        _opts[level]=$1
        ;;

      --max-depth|-d)
        shift
        if [[ ! $1 =~ ^[0-9]+$ ]]; then
          echo -e "ERROR: Max-depth must be a number\n"
          __help
          return 1;
        fi
        _opts[depth]=$1
        ;;

      --nodefine)
        #echo "Don't print function definition"
        _opts[define]=0
        ;;

      --)
        # Standard shell separator between options and arguments
        if ! $_opt_end; then
          _opt_end=true
        fi
        ;;

      -*)
        if ! $_opt_end; then
          echo -e "ERROR: Invalid option: '$1'"
          __help
          return 1;
        fi
        ;&

      *)
        # To support multiple inputs
        while (( $# > 1 )); do
          query ${_cmd_recurse[@]} --level 0 $1
          shift
          echo -e "\n"
        done
        _opts[input]=$1
        ;;
    esac
    shift
  done

  # If you don't give me something to work with, then what am I supposed to do?
  if [[ -z ${_opts[input]} ]]; then
    echo "ERROR: No input specified"
    return 1;
  fi
}


__query_alias() {                                                                                                 # {{{1
  echo "${_query_pp[sep]}${_query_pp[input]} (${_query_pp[type]})"
  while read; do
    echo "${_query_pp[spc]}${REPLY}";
  done < <(command type -a -- "${_opts[input]}" | command head -n2)

  # Recurse
  if (( ${_opts[depth]} == -1 )) || (( ${_query_opts[level]} < ${_query_opts[depth]} )); then
    local _out_arr=()
    read -a _out_arr <<< $(command type -a -- ${_opts[input]} | command grep -Po "(?<=aliased to .).*(?='$)")
    local _query_next=()
    local _level_next=$((${_opts[level]} + 1))
    _query_tree[$_level_next]=0

    local _i=0
    for _i in ${_out_arr[@]}; do
      if [[ "$_i" != "${_opts[input]}" ]]; then
        if [[ $(command type -t -- "$_i") =~ file|function|alias ]]; then
          _query_tree[$_level_next]=$(( ${_query_tree[$_level_next]} + 1 ))
          _query_next+=("$_i")
        fi
      fi
    done
    for _i in ${_query_next[@]}; do
      _query_tree[$_level_next]=$(( ${_query_tree[$_level_next]} - 1 ))
      query "${_cmd_recurse[@]}" --level $_level_next $_i
    done
  fi
}


__query_file() {                                                                                                  # {{{1
  echo "${_query_pp[sep]}${_query_pp[input]} (${_query_pp[type]})"
  while read; do
    echo "${_query_pp[spc]}${REPLY}";
  done < <(command type -a -- "${_opts[input]}" | command head -n1)
}


__query_function() {                                                                                              # {{{1
  echo "${_query_pp[sep]}${_query_pp[input]} (${_query_pp[type]})"
  shopt -s extdebug
  IFS=" " read -a _arr <<< $(command declare -F -- "${_opts[input]}")
  shopt -u extdebug
  echo -e "${_query_pp[spc]}Defined in ${_arr[2]} at line ${_arr[1]}"

  # Print the function definition
  if [[ "${_opts[define]}" == "1" ]]; then
    while read; do
      echo "${_query_pp[spc]}${REPLY}";
    done < <(command type -a -- "${_opts[input]}" | command tail -n+2)
  fi
}


__query_pp() {                                                                                                    # {{{1

  _query_pp[spc]=""
  _query_pp[sep]=""

  # Setup the tree-drawing characters
  if [[ "${_opts[ascii]}" == "1" ]]; then
    local _v_bar='|'
    local _h_bar='-'
    local _x_bar='+'
    local _xl_bar='\'
  else
    local _v_bar='│'
    local _h_bar='─'
    local _x_bar='├'
    local _xl_bar='└'
  fi
  _query_pp[xl]=${_query_pp[xl]:-$_x_bar}

  # Colorize the output?
  if [[ "${_opts[color]}" == "1" ]]; then
    local _c_type="$(tput setaf 4)"
    local _c_input="$(tput bold)$(tput setaf 2)"
    local _c_reset="$(tput sgr0)"
  else
    local _c_type=""
    local _c_input=""
    local _c_reset=""
  fi

  if [[ "${_opts[level]}" != "0" ]]; then
    local _i=0
    for (( _i=1; _i <= ${_opts[level]}; _i++ )); do
      #echo ${_query_tree[$_i]}
      if (( ${_query_tree[$_i]} > 0 )); then
        _query_pp[spc]="${_query_pp[spc]}${_v_bar}   "
      else
        _query_pp[spc]="${_query_pp[spc]}    "
      fi
    done
    if (( ${_query_tree[${_opts[level]}]} == 0 )); then
      _x_bar=$_xl_bar
    fi
    _query_pp[sep]="${_query_pp[spc]%????}${_x_bar}${_h_bar}${_h_bar} "
    echo "${_query_pp[spc]%????}${_v_bar}"
  fi

  _query_pp[type]="${_c_type}${_type}${_c_reset}"
  _query_pp[input]="${_c_input}${_opts[input]}${_c_reset}"
}
# }}}1

  #echo "DEBUG: Cmd='$@'"
  # Default values for options
  local -A _opts=()
  local -a _cmd_recurse=()
  __parse_args "$@"
  local _ret_val=$?
  if [[ "$_ret_val" != "0" ]]; then
    return $_ret_val;
  fi

  local _type=$(command type -t -- "${_opts[input]}")
  #echo "DEBUG: Input='${_opts[input]}', Type='$_type'"

  # Pretty-print the tree structure for recursive lookups
  local -A _query_pp=()
  if (( ${_opts[level]} == 0 )); then
    echo
    local -a _query_tree=()
  fi
  __query_pp

  case $_type in
    "file")
      __query_file
      ;;
    "function")
      __query_function
      ;;
    "alias")
      __query_alias
      ;;
    *)
      command type -a -- "${_opts[input]}"
      ;;
  esac
)
# query:1 ends here

# [[file:~/.config/dotfiles/bash/bashrc.org::*query][query:2]]
alias que=query
# query:2 ends here


# Now, if I run =g SOMETHING= followed by =vq= then =vq= doesn't run as expected because ~!!~ expands to 'g SOMETHING'.
# However, in the expanded form, 'g' doesn't get replaced with grep because of the afore-mentioned limitation.

# To avoid this, I use functions for my most commonly used aliases so that they work everywhere and, aliases only if I'm sure that they won't be used in the middle of a command.


# [[file:~/.config/dotfiles/bash/bashrc.org::*aliases][aliases:2]]
alias ls='ls -FLH --color=always'
alias l=ls
alias la='ls -A'
alias ll='ls -lh'
alias lla='ll -A'
# aliases:2 ends here

# [[file:~/.config/dotfiles/bash/bashrc.org::*aliases][aliases:3]]
alias c=clear
alias cl="c;l"

#alias echo '\echo -e'
#alias lock='/usr/local/bin/xlock'
alias mv='mv -vi'
alias cp='cp -vi'
alias rm='rm -vi'
alias rd='rm -rvf'
alias ln='ln -svi'
alias df='df -h'
alias pppath='tr ":" "\n" <<< $PATH'
alias clnpath='export PATH=$(tr ":" "\n" <<< $PATH | perl -ne "print unless \$seen{\$_}++" | paste -s -d":")'

alias C=cat
alias P=$PAGER
alias hh='history | tail'
alias x=exit
alias k9='kill -9'
alias j='jobs -l'
alias pls='sudo $(history -p !!)'
duh() { du -h "$@" | sort -rh; }

ec() { emacsclient --alternate-editor="" --no-wait --create-frame --quiet "$@" & }
alias e=ec
alias evan='emacs --with-profile vanilla'
# aliases:3 ends here



# From https://askubuntu.com/a/185746/38952
# Using ww twice ensures that the output is not truncated to the width of the terminal

# [[file:~/.config/dotfiles/bash/bashrc.org::*aliases][aliases:4]]
psgrep() { ps wwup $(command pgrep -f "$@"); }
# aliases:4 ends here



# bookmarks for commonly used config files

# [[file:~/.config/dotfiles/bash/bashrc.org::*aliases][aliases:5]]
alias gosc='$VISUAL ~/.bashrc'
alias gost='$VISUAL ~/.dotfiles/tmux/tmux.conf'
alias gosx='$VISUAL ~/.Xresources'
alias sosc='. ~/.bashrc && clnpath'
# aliases:5 ends here

# grep

# [[file:~/.config/dotfiles/bash/bashrc.org::*grep][grep:1]]
export GREP_COLORS='1;32'

alias grep='grep -sP --color=always'
alias gi='grep -i'
alias gv='grep -v'
# grep:1 ends here

# git

# [[file:~/.config/dotfiles/bash/bashrc.org::*git][git:1]]
alias ga='git add'
alias gA='git add -A .'
alias gh='git help'
alias gs='git status'
# git:1 ends here

# perforce

# [[file:~/.config/dotfiles/bash/bashrc.org::*perforce][perforce:1]]
alias pf='p4'
alias pfd='pf diff'
alias pfdg='P4DIFF= pf diff -du | grepdiff --output-matching=hunk'
alias pfe='pf edit'
alias pflog='pf filelog -stl -m 5'
# perforce:1 ends here



# Make opened files prettier by aligning the columns

# [[file:~/.config/dotfiles/bash/bashrc.org::*perforce][perforce:2]]
pfo() {
    pf opened "$@" | command column -s# -o ' #' -t | command column -o ' ' -t | command sed 's/#/   #/'
}

pfor() {
    pf where $(pf opened "$@" | command sed -e 's/#.*//') |
        awk "{ if (\$3 != \"$REPO_PATH/...\") { print \$3; } }" | sed -e "s:$REPO_PATH/::"
}
# perforce:2 ends here



# Show top N (default=10) changes

# [[file:~/.config/dotfiles/bash/bashrc.org::*perforce][perforce:3]]
pftop() {
    local num=10
    if (( $# > 0 )) && [[ "$1" =~ ^[0-9]+$ ]]; then
        num=$1
        shift
    fi
    pf changes -m $num "$@" $STEM/...
}
# perforce:3 ends here

# rm
# Delete in background

# [[file:~/.config/dotfiles/bash/bashrc.org::*rm][rm:1]]
unset -f rm_rf
rm_rf_silent() {
    # FIXME: Doesn't work if there are spaces in the filename
    for i in "$@"; do
        # Remove trailing slash and move to hidden
        ni=${i/%\//}
        bi=$(basename $ni)
        ni=${ni/%$bi/.$bi}

        #echo $ni.$$
        command mv $i $ni.$$
        command rm -rf $ni.$$ &
    done
}
alias rdj='rm_rf_silent'
# rm:1 ends here

# @: a simpler and faster alternative to globstar
# =@ ls /some/long/path/**/that/I/dont/want/to/type= is converted to =ls $(find /some/long/path/ -path '*/that/I/dont/want/to/type')=


# [[file:~/.config/dotfiles/bash/bashrc.org::*@:%20a%20simpler%20and%20faster%20alternative%20to%20globstar][@: a simpler and faster alternative to globstar:1]]
unset -f @
function @ {
    # Description:
    # @ ls /some/long/path/**/that/I/dont/want/to/type is converted to
    #   ls $(find /some/long/path/ -path '*/that/I/dont/want/to/type')

    local _cmd=()
    for i in "$@"; do
        if [[ $i =~ '**' ]]; then
            _cmd+=('$(find'    $(command awk 'BEGIN {FS="**"} {print $1}' <<< "$i"))
            _cmd+=('-path' "'*"$(command awk 'BEGIN {FS="**"} {print $2}' <<< "$i")"')")
        else
            _cmd+=("$i")
        fi
    done
    # echo "${_cmd[@]}"
    # echo
    eval "${_cmd[@]}"
}
# @: a simpler and faster alternative to globstar:1 ends here

# alert
# Simply function to "alert" when a command completes.
# NOTE: This must be used as a function to have access to the history via the fc command

# Use like this: =sleep 10 && alert=

# [[file:~/.config/dotfiles/bash/bashrc.org::*alert][alert:1]]
unset -f alert
alert() {
    # Pick up display message if provided as argument. If not show the last command that was run
    local _msg=${1:-"'$(fc -nl -1 | sed -e 's/^\s*//' -e 's/\s*[;&|]\+\s*alert$//')' has completed"}

    # Add TMUX information if available
    if [[ -n $TMUX ]]; then
        _msg="$(tmux display-message -p "[#S:#I.#P]") $_msg"
    else
        _msg="[$$] $_msg"
    fi

    # Indicate normal completion or error
    local _icon=$( (($? == 0)) && echo terminal || echo error)

    notify-send --urgency=low -i $_icon "$_msg"
}
# alert:1 ends here

# calc
# Simple wrapper around =irb= to make it more natural to use. eg. ~= 4 + 5~

# [[file:~/.config/dotfiles/bash/bashrc.org::*calc][calc:1]]
unset -f =
=() {                                                                                                             # {{{1
    local _input="${@:-$(</dev/stdin)}"
    # echo $_input

    # if [[ $_input =~ [:xdigit:]+\[[:digit:]+:[:digit:]+\] ]]; then
    #   _input=${_input#.*[}
    #   echo $_input
    #   return
    # fi
    # = "($_input >> $_lsb) & ($_msb - $_lsb)"

    # If there's no explicit output formatting, try to infer from the input
    if [[ ! $_input =~ to_s ]]; then
        if [[ $_input =~ 0x ]] || [[ $_input =~ [a-fA-F] ]]; then
            local _base=16
        elif [[ $_input =~ 0b ]]; then
            local _base=2
        fi
        _input="($_input).to_s($_base)"
    fi

    local _result=$(echo "$_input" | irb -m --noverbose | command sed 's/"//g')

    # Pretty-print formatted output
    if [[ $_input =~ 'to_s(16)' ]]; then
        _result="0x${_result}"
    elif [[ $_input =~ 'to_s(2)' ]]; then
        _result="0b${_result}"
    fi

    echo $_result
}
# calc:1 ends here



# Simple base-converter

# [[file:~/.config/dotfiles/bash/bashrc.org::*calc][calc:2]]
unset -f =base
=base() (                                                                                                         # {{{1
    _help () { #{{{
        echo 'SYNTAX:'
        echo '  =base NUM TO [FROM=10]'
        echo '  echo NUM | =base TO [FROM=10]'
        echo '  =base TO [FROM=10] <<< "NUM"'
    } # }}}

    if (( $# <= 1 )); then
        echo -e "ERROR: Insufficient arguments. At least two required\n"; _help
        return 1
    fi

    if [[ -p /dev/stdin ]] || [[ -s /dev/stdin ]]; then
        # From pipe or from redirection respectively
        local _num=$(</dev/stdin)
    else
        local _num=$1
        shift
    fi

    local _obase=$1
    local _ibase=${2:-10}

    case $_ibase in
        2)  _num=${_num#0[bB]} ;;
        16) _num=$(tr '[a-f]' '[A-F]' <<< "${_num#0[xX]}") ;;
    esac

    local _result=$(echo "obase=$_obase; ibase=$_ibase; $_num" | bc)
    case $_obase in
        2)  _result="0b${_result}" ;;
        16) _result="0x${_result}" ;;
    esac

    echo $_result
)

=bin() { =base $1  2 ${2:-10}; }  # Convert to binary, by default from decimal
=dec() { =base $1 10 ${2:-16}; }  # Convert to decimal, by default from hexadecimal
=hex() { =base $1 16 ${2:-10}; }  # Convert to hexadecimal, by default from decimal
# calc:2 ends here

# [[file:~/.config/dotfiles/bash/bashrc.org::*calc][calc:3]]
unset -f =slice
=slice() (
    _help() {
        echo 'SYNTAX:'
        echo '  =slice NUM MSB LSB'
        echo '  =slice NUM BIT'
        echo '  echo NUM | =slice MSB LSB'
        echo '  =slice MSB LSB <<< "NUM"'
        echo
        echo "NOTE: MSB >= LSB"
    }

    if (( $# >= 3 )); then
        local _num=$1
        shift
    elif [[ -p /dev/stdin ]] || [[ -s /dev/stdin ]]; then
        # From pipe or from redirection respectively
        local _num=$(</dev/stdin)
    elif (( $# < 1 )); then
        echo -e "ERROR: Insufficient arguments. At least one more required\n"; _help
        return 1
    else
        local _num=$1
        shift
    fi

    local _msb=$1
    local _lsb=${2:-$_msb}

    if (( $_lsb > $_msb )); then
        echo -e "ERROR: MSB must be greater than or equal to LSB when slicing\n"; _help
        return 1
    fi

    # echo "in=$_num, msb=$_msb, lsb=$_lsb"
    = "($_num >> $_lsb) & ((1 << ($_msb - $_lsb + 1)) - 1)"
)
# calc:3 ends here

# dir related

# [[file:~/.config/dotfiles/bash/bashrc.org::*dir%20related][dir related:1]]
alias md='mkdir -p'

# Create new dir(s) and enter it (last directory if multiple arguments are given)
unset -f mcd
mcd() {
    command mkdir -p "$@" || return
    cd -- "${@: -1}"
}
# dir related:1 ends here



# NOTE: The use of $* is deliberate here as it produces all the scripts arguments separated by the first character of $IFS which, by default, is a space. This allows me to match all arguments against a regex in one go instead of looping over them

# [[file:~/.config/dotfiles/bash/bashrc.org::*dir%20related][dir related:2]]
dirs() {
    if (( $# == 0 )); then
        builtin dirs -v
    elif [[ "$*" =~ [-+][0-9]+ ]]; then
        # Use long-listing format. Without this, the home directory is display as '~' preventing me from doing something
        # like `cp $(dirs +1)` as it results in an error: pushd: ~/.vim: No such file or directory
        builtin dirs "$@" -l
    else
        builtin dirs "$@"
    fi
}
# dir related:2 ends here



# Silent pushd and uniquifies while pushing

# [[file:~/.config/dotfiles/bash/bashrc.org::*dir%20related][dir related:3]]
pushd() {
    builtin pushd "$@" > /dev/null;

    # Remove any duplicate entries. The 1st entry will be the PWD so skip it
    local _dir_pos=$(dirs -l -v | tail -n+2 | grep "$PWD$" | sed 's/^\s*//' | cut -d ' ' -f1 | paste -s)
    command popd -n +$_dir_pos &> /dev/null
}
# dir related:3 ends here



# Better dirstack. Adds the following to the usual =cd= behavior:
# - =cd ==           Lists the contents of the stack and use fzf to select from it
# - =cd=             (with no args) Goes to $REPO_PATH if it's set else goes to $HOME
# - =cd ... [TARG]=  Jump to a directory in the path that starts with TARG.
#                  If TARG is not given, show all directories in the filepath and use fzf to select

# Note that =pushd= calls =cd= under the hood. So =cdable_vars= and =cdspell= apply to =pushd= as well

# [[file:~/.config/dotfiles/bash/bashrc.org::*dir%20related][dir related:4]]
cd() {
    if (( "$#" == 0 )); then
        if vcs::is_in_repo > /dev/null; then
            cd "$(vcs::get_root)"
        else
            cd "$HOME"
        fi
        return
    fi

    case "$1" in
        -)
            pushd
            return
            ;;

        =)
            if hash fzf 2> /dev/null; then
                $(FZF_ALT_C_COMMAND='command dirs -l -p' __fzf_cd__)
            else
                dirs
            fi
            return
            ;;

        ...)
            if hash fzf 2> /dev/null; then
                $(FZF_ALT_C_COMMAND='_dir=$PWD; while [[ -n "$_dir" ]]; do _dir="${_dir%/[^/]*}"; echo ${_dir:-/}; done' \
                    FZF_ALT_C_OPTS="${FZF_ALT_C_OPTS} --select-1 ${2+ --query=$2}" __fzf_cd__)
            fi
            return
            ;;

        *\*\**)
            # Split $1 about the first ** into '_path' and '_pattern'.
            local _path=${1%%\*\**}; _path=${_path:-.}
            local _pattern="*$(tr -s '*' <<< ${1#*\*\*})*"

            if hash fzf 2> /dev/null; then
                # Find '_path' for all dirs that match the glob expr '_pattern' and select with FZF from the results
                $(FZF_ALT_C_COMMAND="find ${_path} -type d -path '*${_pattern}*'" __fzf_cd__)
                return
            else
                _dir=$(find $_path -type d -path "*${_pattern}*" -print -quit)
                if [[ -n $_dir ]]; then
                    pushd "$_dir"
                fi
            fi
            ;;
    esac

    pushd "$@"
}

alias ..='cd ..'
# dir related:4 ends here

# [[https://github.com/junegunn/fzf][fzf]]


# [[file:~/.config/dotfiles/bash/bashrc.org::*%5B%5Bhttps://github.com/junegunn/fzf%5D%5Bfzf%5D%5D][[[https://github.com/junegunn/fzf][fzf]]:1]]
if [[ -d /opt/fzf ]]; then
    export FZF_PATH=/opt/fzf
elif [[ -d $HOME/.local/install/fzf ]]; then
    export FZF_PATH="$HOME/.local/install/fzf"
else
    echo "$(tput setaf 1)ERROR$(tput sgr0): FZF_PATH is not set"
fi

if [[ -n "$FZF_PATH" ]]; then
    [[ ! "$PATH" == *$FZF_PATH/bin* ]] && export PATH="$PATH:$FZF_PATH/bin"

    # Key bindings
    # Note the order is important because some functions get overridden
    source $FZF_PATH/shell/key-bindings.bash
    source ${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/fzf/fzf_vcs.bash
    source ${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/fzf/key-bindings.bash

    # Customisations
    if hash fd 2> /dev/null; then
        export FZF_DEFAULT_COMMAND="fd --color=never --hidden --exclude .git --type f"
        export FZF_ALT_C_COMMAND="fd --color=never --hidden --exclude .git --type d"
        export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
    fi

    # Clear out old env vars
    export FZF_DEFAULT_OPTS="--ansi --select-1 --exit-0 --inline-info --reverse --tiebreak=length,end --bind=shift-tab:toggle-all,ctrl-n:down,ctrl-p:up"
    unset FZF_ALT_C_OPTS
    unset FZF_CTRL_T_OPTS
    # export FZF_CTRL_T_OPTS='--expect=alt-v,alt-e,alt-c'

    # base16 fzf colorscheme is applied by appending to the FZF_DEFAULT_OPTS env var
    # Thus, I "set" it first before sourcing the base16 file which appends to it
    export BASE16_FZF=${XDG_CONFIG_HOME:-$HOME/.config}/base16-fzf
    [[ -n "$BASE16_THEME" ]] && source "$BASE16_FZF/bash/base16-${BASE16_THEME}.config"
fi
# [[https://github.com/junegunn/fzf][fzf]]:1 ends here

# [[https://github.com/BurntSushi/ripgrep][ripgrep]]
# :PROPERTIES:
# :header-args+: :tangle (if (executable-find "rg") (concat (getenv "HOME") "/.bashrc") "no")
# :END:
# This will be tangled only if =rg= exists

# [[file:~/.config/dotfiles/bash/bashrc.org::*%5B%5Bhttps://github.com/BurntSushi/ripgrep%5D%5Bripgrep%5D%5D][[[https://github.com/BurntSushi/ripgrep][ripgrep]]:1]]
export RIPGREP_CONFIG_PATH=${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/ripgreprc
alias g='command rg'
# [[https://github.com/BurntSushi/ripgrep][ripgrep]]:1 ends here

# vim

# [[file:~/.config/dotfiles/bash/bashrc.org::*vim][vim:1]]
alias v=vim
alias vi="vim -u NORC -U NORC -N --cmd 'set rtp="'$VIM,$VIMRUNTIME,$VIM/after'"'"
# vim:1 ends here



# Open results of the last shell command in vim quickfix.
# Very useful for searching something using =rg= etc. and iterating through the results in vim

# [[file:~/.config/dotfiles/bash/bashrc.org::*vim][vim:2]]
vq() { v -q <(eval "$(fc -nl -1) $@"); }
# vim:2 ends here



# Opening up vimdiff takes noticeable amount of time. This will run it only if required.
# Using -f keeps the window in the foreground and prevents a whole bunch of diffs opening at the same time

# [[file:~/.config/dotfiles/bash/bashrc.org::*vim][vim:3]]
gvim_diff() {
    # Check to see if all files are present. If not, return.
    for i in "$@"; do
        [[ ! -f "$i" ]] && return
    done

    # If there are no differences, print that files are identical and return
    command diff -qs "$@" && return

    # Run vimdiff only if there are differences and all files are present
    gvim -df -c 'set nobackup' "$@"
}
alias vd=gvim_diff
# vim:3 ends here

# [[https://github.com/tmux/tmux][tmux]]

# [[file:~/.config/dotfiles/bash/bashrc.org::*%5B%5Bhttps://github.com/tmux/tmux%5D%5Btmux%5D%5D][[[https://github.com/tmux/tmux][tmux]]:1]]
source ${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/tmux/tmuxw.bash
alias tmux='tmuxw'
alias tm='tmux'
# [[https://github.com/tmux/tmux][tmux]]:1 ends here

# prompt
# [[https://wiki.archlinux.org/index.php/Bash/Prompt_customization][Prompt Customization on ArchWiki]]:
# =PS1= is the primary prompt displayed before each command.
# =PS2= is the secondary prompt used in case of a multi-line command
# =PROMPT_COMMAND= is evaluated right before PS1 is displayed.

# I use this by assigning it to a function which updates PS1 and PS2 allowing me to have a dynamic prompt

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:1]]
PROMPT_COMMAND=__setprompt
# prompt:1 ends here



# Use bash builtin =checkwinsize= option for terminals which fail to properly set the $COLUMNS variable. (bug workaround)

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:2]]
shopt -s checkwinsize
# prompt:2 ends here



# Contract the following: /proj/ch_func_dev{1:0}/ASPEN_HIGHLANDS -> ~AH{1:0}
# Contract more if it's my directory

# [[file:~/.config/dotfiles/bash/bashrc.org::*Colors%20and%20helper%20functions][Colors and helper functions:2]]
prompt::get_compact_pwd() {
    local _pwd=$PWD
    if [[ "$_pwd" =~ ^"$HOME" ]]; then
        _pwd=${_pwd/#$HOME/\~};
    fi
    echo $_pwd
}
# Colors and helper functions:2 ends here

# prompt
# This is based on [[http://stevelosh.com/blog/2010/02/my-extravagant-zsh-prompt/][SJL's prompt]] and [[http://aperiodic.net/phil/prompt/][Phil's Zsh prmpt]]. This is what it looks like:
# #+begin_example
#   ┌ kshenoy @ svvgar-nx16 in ~/.vim ───────────────────── 03:57pm Aug 02, Fri
#   └ (^_^) ➤
# #+end_example

# The function has to be called '__setprompt' as that's what =PROMPT_COMMAND= is set to

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:1]]
__setprompt() {
    # Colors and line-graphics that I use commonly
    local _reset="\[$(tput sgr0)\]"
    local _bold="\[$(tput bold)\]"
    local _fg_black="\[$(tput setaf 0)\]"
    local _fg_light_black="\[$(tput setaf 8)\]"
    local _fg_red="\[$(tput setaf 1)\]"
    local _fg_yellow="\[$(tput setaf 3)\]"
    local _fg_green="\[$(tput setaf 2)\]"
    local _fg_blue="\[$(tput setaf 4)\]"
    local _fg_purple="\[$(tput setaf 5)\]"
    
    # Set line graphics
    local _dash="─"
    local _ulcorner="┌"
    # local _ulcorner="╭"
    local _llcorner="└"
    # local _llcorner="╰"
# prompt:1 ends here



# This is all the information I need to set my prompt!

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:2]]
# This has to be placed first
local _exit_status="$?"

# We use this instead of $COLUMNS as when a shell is starting, the $COLUMNS variable is not set
local _columns=$(tput cols)

# The info variables
local _pwd=$(prompt::get_compact_pwd)

# Force time to US Mountain Time. I don't want to export TZ as it messes up some other scripts
local _time="$(TZ=US/Mountain date +%I:%M%P) "
local _user="$(whoami) "
local _user_host_sep="@ "
local _pwd_sep="in "
local _host="$(hostname) "
# prompt:2 ends here



# If root user then colour the arrow red.

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:3]]
if (( "$UID" == 0 )); then
    local _fg_user_symbol=$_fg_red
else
    local _fg_user_symbol=${_bold}${_fg_light_black}
fi
# prompt:3 ends here



# VCS specific

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:4]]
local _vcs_type=$(vcs::get_type)
local _vcs_branch=$(vcs::get_branch $_vcs_type)
local _vcs_sep=" on "

if [[ $_vcs_type == "git" ]]; then
    local _user_symbol=" ±"
elif [[ $_vcs_type == "hg" ]]; then
    local _user_symbol=" ☿"
elif [[ $_vcs_type == "p4" ]]; then
    local _vcs_sep=" on "
else
    #local _user_symbol=" ○"
    #local _user_symbol=" ➤"
    local _user_symbol=" $"
    local _vcs_sep=""
fi
# prompt:4 ends here



# Here, I try to decide what all to put on the prompt depending on the width of the screen.
# I work backwards by constructing the full prompt and remove stuff if it's longer than the screen width as most of the it won't be.

# Start with everything of interest

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:5]]
_info="${_ulcorner} ${_user}${_user_host_sep}${_host}${_pwd_sep}${_pwd}${_vcs_sep}${_vcs_branch} ${_time}"
# prompt:5 ends here



# If info is wider than the screen, drop the time

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:6]]
if (( $_columns < ${#_info} )); then
    _time=""
    _info="${_ulcorner} ${_user}${_user_host_sep}${_host}${_pwd_sep}${_pwd}${_vcs_sep}${_vcs_branch} "
fi
_pwd_sep="${_fg_light_black}${_pwd_sep}${_reset}"
# prompt:6 ends here



# If the info still can't fit, drop user and domain info

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:7]]
if (( $_columns < ${#_info} )); then
    _user=""
    _user_host_sep=""
    _host=""
    _pwd_sep=""
    _info="${_ulcorner} ${_pwd}${_vcs_sep}${_vcs_branch} "
fi
# prompt:7 ends here



# If the info still can't fit, drop vcs branch

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:8]]
if (( $_columns < ${#_info} )); then
    _vcs_sep=""
    _vcs_branch=""
    _info="${_ulcorner} ${_pwd} "
fi
# prompt:8 ends here



# If the info still can't fit, truncate PWD

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:9]]
if (( $_columns < ${#_info} )); then
    _pwd_sep="..."
    while (( $_columns < ${#_info} )); do
        _pwd=`echo $_pwd | sed 's|^/\?[^/]*/||'`
        _info="${_ulcorner} ${_pwd_sep}${_pwd} "
    done
    _pwd_sep="${_bold}${_fg_green}${_pwd_sep}${_reset}"
fi

local _fillsize=$(( $_columns - ${#_info} - 1 ))
local _fill=$(printf "${_dash}%.0s" $(seq 1 $_fillsize))" "
# prompt:9 ends here



# Colorize vcs:

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:10]]
if [[ $_vcs_type == "git" ]]; then
    local _vcs_status=$(vcs::get_status ${_vcs_type} ${_vcs_branch})
    if [[ "${_vcs_status}" == "staged" ]]; then
        _vcs_branch="${_fg_yellow}${_vcs_branch}${_reset}"
    elif [[ "${_vcs_status}" == "modified" ]]; then
        _vcs_branch="${_fg_red}${_vcs_branch}${_reset}"
    elif [[ "${_vcs_status}" == "committed" ]]; then
        _vcs_branch="${_fg_green}${_vcs_branch}${_reset}"
    fi
elif [[ $_vcs_type == "p4" ]]; then
    if (( $(p4 opened 2> /dev/null | wc -l) > 0 )); then
        _vcs_branch="${_fg_red}${_vcs_branch}${_reset}"
    else
        _vcs_branch="${_fg_green}${_vcs_branch}${_reset}"
    fi
fi
# prompt:10 ends here



# Create exit status indicator based on exit status of last command

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:11]]
if (( "$_exit_status" == 0 )); then
    _exit_status="${_bold}${_fg_green} (^_^)"
else
    _exit_status="${_fg_red} (@_@)"
fi
# prompt:11 ends here



# Now that I've decided what all I want to put on the prompt and how, it's time to set the prompt variables

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:12]]
PS1="\n${_reset}"
PS1+="${_fg_light_black}${_ulcorner}${_reset} "
PS1+="${_fg_red}${_user}${_reset}"
PS1+="${_fg_light_black}${_user_host_sep}${_reset}"
PS1+="${_fg_yellow}${_host}${_reset}"
PS1+="${_pwd_sep}"
PS1+="${_fg_blue}${_pwd}${_reset}"
PS1+="${_fg_light_black}${_vcs_sep}${_reset}"
PS1+="${_vcs_branch} "
PS1+="${_fg_light_black}${_fill}${_reset}"
PS1+="${_fg_yellow}${_time}${_reset}"
PS1+="\n"
PS1+="${_fg_light_black}${_llcorner}${_reset}"
PS1+="${_exit_status}${_reset}"
PS1+="${_fg_user_symbol}${_user_symbol}${_reset} "

PS2="      ${_fg_user_symbol}...${_reset}   "
# prompt:12 ends here



# Evaluate dynamic variables only if dyn_vars is defined (Not required for prompt)

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:13]]
declare -F dyn_vars &> /dev/null && dyn_vars
# prompt:13 ends here



# Set HISTFILE here to keep it current when sessions span multiple days
# FIXME: Find a better way to do this i.e. do it once a day instead of everytime the prompt is refreshed

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:14]]
HISTFILE="${XDG_DATA_HOME:-$HOME/.local/share}/bash_history/$(date +%Y/%m/%d)_${HOSTNAME%%.*}_${USER}_$$"
[[ -d $(dirname ${HISTFILE}) ]] || mkdir -p $(dirname ${HISTFILE})
# prompt:14 ends here



# Write to the history file immediately instead of waiting till the end of the session

# [[file:~/.config/dotfiles/bash/bashrc.org::*prompt][prompt:15]]
history -a
}
# prompt:15 ends here

# PATH

# [[file:~/.config/dotfiles/bash/bashrc.org::*PATH][PATH:1]]
if ((which ruby &> /dev/null) && (which gem &> /dev/null)); then
  export PATH="$(ruby -rubygems -e 'puts Gem.user_dir')/bin:$PATH"
fi
export PATH="$HOME/bin:$HOME/.local/bin:$PATH"
clnpath
# PATH:1 ends here

# home
# Update permissions of the history when exiting as root

# [[file:~/.config/dotfiles/bash/bashrc.org::*home][home:1]]
__histfile_perm_update__() {
    if [[ -f $HISTFILE ]]; then
        echo "Changing permissions of HISTFILE..."
        chown kshenoy $HISTFILE
        chgrp kshenoy $HISTFILE
        chmod 640 $HISTFILE
    fi
}
trap __histfile_perm_update__ EXIT

## When leaving the console, clear the screen to increase privacy
if [[ "$SHLVL" = 1 ]]; then
    [[ -x /usr/bin/clear_console ]] && /usr/bin/clear_console -q
fi
# home:1 ends here

# bashrc_local
# And finally, check for a .bashrc_local and load it

# [[file:~/.config/dotfiles/bash/bashrc.org::*bashrc_local][bashrc_local:1]]
[[ -f ~/.bashrc_local_override ]] && . ~/.bashrc_local_override
# bashrc_local:1 ends here

# command completion

# [[file:~/.config/dotfiles/bash/bashrc.org::*command%20completion][command completion:1]]
if [[ -f /etc/bash_completion ]] && ! shopt -oq posix; then
    . /etc/bash_completion
fi

complete -A hostname   rsh rcp telnet rlogin r ftp ping disk
complete -A export     printenv
complete -A variable   export local readonly unset
complete -A enabled    builtin
complete -A alias      alias unalias
complete -A function   function
complete -A user       su mail finger

complete -A helptopic  help     # currently same as builtins
complete -A shopt      shopt
complete -A stopped -P '%' bg
complete -A job -P '%' fg jobs disown

complete -A directory  mkdir rmdir
complete -A directory  -o default cd

# Compression
complete -f -o default -X '*.+(zip|ZIP)'  zip
complete -f -o default -X '!*.+(zip|ZIP)' unzip
complete -f -o default -X '*.+(z|Z)'      compress
complete -f -o default -X '!*.+(z|Z)'     uncompress
complete -f -o default -X '*.+(gz|GZ)'    gzip
complete -f -o default -X '!*.+(gz|GZ)'   gunzip
complete -f -o default -X '*.+(bz2|BZ2)'  bzip2
complete -f -o default -X '!*.+(bz2|BZ2)' bunzip2

# Misc filetypes
complete -f -o default -X '!*.ps'  gs ghostview ps2pdf ps2ascii
complete -f -o default -X '!*.dvi' dvips dvipdf xdvi dviselect dvitype
complete -f -o default -X '!*.pdf' acroread pdf2ps
complete -f -o default -X '!*.+(pdf|ps)' gv
complete -f -o default -X '!*.texi*' makeinfo texi2dvi texi2html texi2pdf
complete -f -o default -X '!*.tex' tex latex slitex
complete -f -o default -X '!*.lyx' lyx
complete -f -o default -X '!*.+(htm*|HTM*)' lynx html2ps
complete -f -o default -X '!*.pl'  perl perl5
complete -f -o default -X '!*.gv'   dot
complete -f -o default -X '!*.gif'  kview

# Multimedia
#complete -f -o default -X '!*.+(jp*g|gif|xpm|png|bmp)' xv gimp
#complete -f -o default -X '!*.+(mp3|MP3)' mpg123 mpg321
#complete -f -o default -X '!*.+(ogg|OGG)' ogg123
# command completion:1 ends here

# fzf completion
# Rest of fzf configuration defined above: [[*\[\[https://github.com/junegunn/fzf\]\[fzf\]\]][fzf]]


# [[file:~/.config/dotfiles/bash/bashrc.org::*fzf%20completion][fzf completion:1]]
[[ $- == *i* ]] && source "$FZF_PATH/shell/completion.bash" 2> /dev/null
# fzf completion:1 ends here

# alias completion
# Automatically add completion for all aliases to commands having completion functions
# This must be called only at the very end


# [[file:~/.config/dotfiles/bash/bashrc.org::*alias%20completion][alias completion:1]]
_compl_alias() {
    [[ -z "$1" ]] && return
    local _alias="$1"

    if (( $# >= 2 )); then
        local _cmd="$2"
    else
        local _cmd="$(alias $_alias 2> /dev/null | sed -e 's/^.*=//' -e 's/ .*$//' | tr -d "'")"
    fi
    [[ -z "$_cmd" ]] && return

    eval "$(complete -p $_cmd | sed "s/$_cmd$/$_alias/")"
}
# alias completion:1 ends here



# Note the order of application is important

# [[file:~/.config/dotfiles/bash/bashrc.org::*alias%20completion][alias completion:2]]
_compl_alias e    emacs
_compl_alias g    grep
_compl_alias v    vim
_compl_alias vd   diff
_compl_alias vile less
for _alias in C P gi gv l la ll lla doomacs; do
    _compl_alias "$_alias"
done
# alias completion:2 ends here
