# Git configuration

[user]
name  = Kartik Shenoy
email = theresmorethanoneway@gmail.com

[core]
editor   = vim
fileMode = false
# Centralize all hooks instead of configuring them on a per-repository basis
hooksPath = ~/.config/git/hooks/

[init]
defaultBranch = main

[color]
ui     = auto
branch = auto
diff   = auto
status = auto

[color "branch"]
current = green
remote  = red

[color "diff"]
meta = yellow
frag = magenta
old = red bold
new = green
plain = white

[color "status"]
added = yellow
changed = red
untracked = cyan

[diff]
tool = nvim
algorithm = histogram
colorMoved = default

[difftool]
prompt = false

[difftool "nvim"]
cmd = nvim -d $LOCAL $REMOTE

[merge]
tool = meld
conflictstyle = diff3

[mergetool]
prompt = false

[mergetool "meld"]
cmd = meld $LOCAL $MERGED $REMOTE --output $MERGED --diff $BASE $LOCAL --diff $BASE $REMOTE --diff $LOCAL $REMOTE --diff $LOCAL $MERGED --diff $REMOTE $MERGED
trustExitCode = false

[mergetool "vim"]
cmd = vim_merge $BASE $REMOTE $LOCAL $MERGED
trustExitCode = true

[mergetool "nvim"]
cmd = nvim $BASE $REMOTE $LOCAL $MERGED
trustExitCode = true

[rerere]
enabled = true

[credential]
helper = cache --timeout=3600

[pull]
rebase = false

[push]
default = simple

[alias]
# https://haacked.com/archive/2014/07/28/github-flow-aliases/
# Using =!= as prefix allows running any command in the shell and it doesn't have to be a git command.
# Thus, if we want to create an alias to run multiple commands by chaining them together, we have to use =!=
alias = !git config -l | grep alias | cut -c 7-
st = status
d  = diff
dw = diff --word-diff
dt = difftool
mt = mergetool
ci = commit
co = checkout
br = branch
lg = log --color --graph --pretty=format:' %C(yellow)%h%C(reset) %s %C(green)(%cr) %C(bold blue)<%an>%C(red)%d%C(reset)' --abbrev-commit --all
unstage = reset HEAD --
last = log -1 HEAD
amend = commit --amend --no-edit

# Safer wipes. Using =git reset HEAD --hard= leaves no room for undoing anything.
# This commits everything and then does a hard reset to remove that commit. The nice thing is, the commit is still
# there, but it’s just unreachable. Unreachable commits are a bit inconvenient to restore, but at least they are still
# there. I can run the =git reflog= command and find the SHA of the commit if I realize later that I made a mistake with
# the reset. The commit message will be “WIPE SAVEPOINT” in this case.
wipe = !git add -A && git commit -qm 'WIPE SAVEPOINT' && git reset HEAD~1 --hard
